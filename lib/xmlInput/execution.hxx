// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef EXECUTION_HXX
#define EXECUTION_HXX

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 3030000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type type;
  typedef ::xsd::cxx::tree::simple_type< type > simple_type;
  typedef ::xsd::cxx::tree::type container;

  // 8-bit
  //
  typedef signed char byte;
  typedef unsigned char unsigned_byte;

  // 16-bit
  //
  typedef short short_;
  typedef unsigned short unsigned_short;

  // 32-bit
  //
  typedef int int_;
  typedef unsigned int unsigned_int;

  // 64-bit
  //
  typedef long long long_;
  typedef unsigned long long unsigned_long;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long integer;
  typedef long long non_positive_integer;
  typedef unsigned long long non_negative_integer;
  typedef unsigned long long positive_integer;
  typedef long long negative_integer;

  // Boolean.
  //
  typedef bool boolean;

  // Floating-point types.
  //
  typedef float float_;
  typedef double double_;
  typedef double decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< char, simple_type > string;
  typedef ::xsd::cxx::tree::normalized_string< char, string > normalized_string;
  typedef ::xsd::cxx::tree::token< char, normalized_string > token;
  typedef ::xsd::cxx::tree::name< char, token > name;
  typedef ::xsd::cxx::tree::nmtoken< char, token > nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< char, simple_type, nmtoken > nmtokens;
  typedef ::xsd::cxx::tree::ncname< char, name > ncname;
  typedef ::xsd::cxx::tree::language< char, token > language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< char, ncname > id;
  typedef ::xsd::cxx::tree::idref< char, ncname, type > idref;
  typedef ::xsd::cxx::tree::idrefs< char, simple_type, idref > idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< char, simple_type > uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< char, simple_type, uri, ncname > qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< char > buffer;
  typedef ::xsd::cxx::tree::base64_binary< char, simple_type > base64_binary;
  typedef ::xsd::cxx::tree::hex_binary< char, simple_type > hex_binary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone time_zone;
  typedef ::xsd::cxx::tree::date< char, simple_type > date;
  typedef ::xsd::cxx::tree::date_time< char, simple_type > date_time;
  typedef ::xsd::cxx::tree::duration< char, simple_type > duration;
  typedef ::xsd::cxx::tree::gday< char, simple_type > gday;
  typedef ::xsd::cxx::tree::gmonth< char, simple_type > gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< char, simple_type > gmonth_day;
  typedef ::xsd::cxx::tree::gyear< char, simple_type > gyear;
  typedef ::xsd::cxx::tree::gyear_month< char, simple_type > gyear_month;
  typedef ::xsd::cxx::tree::time< char, simple_type > time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< char, ncname > entity;
  typedef ::xsd::cxx::tree::entities< char, simple_type, entity > entities;

  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags flags;
  typedef ::xsd::cxx::tree::properties< char > properties;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity severity;
  typedef ::xsd::cxx::tree::error< char > error;
  typedef ::xsd::cxx::tree::diagnostics< char > diagnostics;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< char > exception;
  typedef ::xsd::cxx::tree::bounds< char > bounds;
  typedef ::xsd::cxx::tree::duplicate_id< char > duplicate_id;
  typedef ::xsd::cxx::tree::parsing< char > parsing;
  typedef ::xsd::cxx::tree::expected_element< char > expected_element;
  typedef ::xsd::cxx::tree::unexpected_element< char > unexpected_element;
  typedef ::xsd::cxx::tree::expected_attribute< char > expected_attribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > unexpected_enumerator;
  typedef ::xsd::cxx::tree::expected_text_content< char > expected_text_content;
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > no_prefix_mapping;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< char > error_handler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::auto_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
class TendonElementType;
class TendonType;
class ActivationElementType;
class ActivationType;
class SimulatedAnnealingType;
class HybridAlgorithmType;
class OpenLoopType;
class MuscleListType;
class HybridType;
class TypeType;
class NMSModelType;
class ElaboratedDoFsType;
class ExecutionElementType;
class FileType;
class LoggingType;
class ExecutionType;

#include <memory>    // std::auto_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

class TendonElementType: public ::xml_schema::type
{
  public:
  // Constructors.
  //
  TendonElementType ();

  TendonElementType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  TendonElementType (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  TendonElementType (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  TendonElementType (const TendonElementType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  virtual TendonElementType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~TendonElementType ();
};

class TendonType: public ::xml_schema::type
{
  public:
  // stiff
  // 
  typedef ::TendonElementType stiff_type;
  typedef ::xsd::cxx::tree::optional< stiff_type > stiff_optional;
  typedef ::xsd::cxx::tree::traits< stiff_type, char > stiff_traits;

  const stiff_optional&
  stiff () const;

  stiff_optional&
  stiff ();

  void
  stiff (const stiff_type& x);

  void
  stiff (const stiff_optional& x);

  void
  stiff (::std::auto_ptr< stiff_type > p);

  // elastic
  // 
  typedef ::TendonElementType elastic_type;
  typedef ::xsd::cxx::tree::optional< elastic_type > elastic_optional;
  typedef ::xsd::cxx::tree::traits< elastic_type, char > elastic_traits;

  const elastic_optional&
  elastic () const;

  elastic_optional&
  elastic ();

  void
  elastic (const elastic_type& x);

  void
  elastic (const elastic_optional& x);

  void
  elastic (::std::auto_ptr< elastic_type > p);

  // elasticBiSec
  // 
  typedef ::TendonElementType elasticBiSec_type;
  typedef ::xsd::cxx::tree::optional< elasticBiSec_type > elasticBiSec_optional;
  typedef ::xsd::cxx::tree::traits< elasticBiSec_type, char > elasticBiSec_traits;

  const elasticBiSec_optional&
  elasticBiSec () const;

  elasticBiSec_optional&
  elasticBiSec ();

  void
  elasticBiSec (const elasticBiSec_type& x);

  void
  elasticBiSec (const elasticBiSec_optional& x);

  void
  elasticBiSec (::std::auto_ptr< elasticBiSec_type > p);

  // Constructors.
  //
  TendonType ();

  TendonType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  TendonType (const TendonType& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  virtual TendonType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~TendonType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  stiff_optional stiff_;
  elastic_optional elastic_;
  elasticBiSec_optional elasticBiSec_;
};

class ActivationElementType: public ::xml_schema::type
{
  public:
  // Constructors.
  //
  ActivationElementType ();

  ActivationElementType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  ActivationElementType (const ::xercesc::DOMAttr& a,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  ActivationElementType (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  ActivationElementType (const ActivationElementType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  virtual ActivationElementType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~ActivationElementType ();
};

class ActivationType: public ::xml_schema::type
{
  public:
  // exponential
  // 
  typedef ::ActivationElementType exponential_type;
  typedef ::xsd::cxx::tree::optional< exponential_type > exponential_optional;
  typedef ::xsd::cxx::tree::traits< exponential_type, char > exponential_traits;

  const exponential_optional&
  exponential () const;

  exponential_optional&
  exponential ();

  void
  exponential (const exponential_type& x);

  void
  exponential (const exponential_optional& x);

  void
  exponential (::std::auto_ptr< exponential_type > p);

  // piecewise
  // 
  typedef ::ActivationElementType piecewise_type;
  typedef ::xsd::cxx::tree::optional< piecewise_type > piecewise_optional;
  typedef ::xsd::cxx::tree::traits< piecewise_type, char > piecewise_traits;

  const piecewise_optional&
  piecewise () const;

  piecewise_optional&
  piecewise ();

  void
  piecewise (const piecewise_type& x);

  void
  piecewise (const piecewise_optional& x);

  void
  piecewise (::std::auto_ptr< piecewise_type > p);

  // Constructors.
  //
  ActivationType ();

  ActivationType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  ActivationType (const ActivationType& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  virtual ActivationType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~ActivationType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  exponential_optional exponential_;
  piecewise_optional piecewise_;
};

class SimulatedAnnealingType: public ::xml_schema::type
{
  public:
  // noEpsilon
  // 
  typedef ::xml_schema::int_ noEpsilon_type;
  typedef ::xsd::cxx::tree::traits< noEpsilon_type, char > noEpsilon_traits;

  const noEpsilon_type&
  noEpsilon () const;

  noEpsilon_type&
  noEpsilon ();

  void
  noEpsilon (const noEpsilon_type& x);

  // rt
  // 
  typedef ::xml_schema::double_ rt_type;
  typedef ::xsd::cxx::tree::traits< rt_type, char, ::xsd::cxx::tree::schema_type::double_ > rt_traits;

  const rt_type&
  rt () const;

  rt_type&
  rt ();

  void
  rt (const rt_type& x);

  // T
  // 
  typedef ::xml_schema::double_ T_type;
  typedef ::xsd::cxx::tree::traits< T_type, char, ::xsd::cxx::tree::schema_type::double_ > T_traits;

  const T_type&
  T () const;

  T_type&
  T ();

  void
  T (const T_type& x);

  // NS
  // 
  typedef ::xml_schema::int_ NS_type;
  typedef ::xsd::cxx::tree::traits< NS_type, char > NS_traits;

  const NS_type&
  NS () const;

  NS_type&
  NS ();

  void
  NS (const NS_type& x);

  // NT
  // 
  typedef ::xml_schema::int_ NT_type;
  typedef ::xsd::cxx::tree::traits< NT_type, char > NT_traits;

  const NT_type&
  NT () const;

  NT_type&
  NT ();

  void
  NT (const NT_type& x);

  // epsilon
  // 
  typedef ::xml_schema::double_ epsilon_type;
  typedef ::xsd::cxx::tree::traits< epsilon_type, char, ::xsd::cxx::tree::schema_type::double_ > epsilon_traits;

  const epsilon_type&
  epsilon () const;

  epsilon_type&
  epsilon ();

  void
  epsilon (const epsilon_type& x);

  // maxNoEval
  // 
  typedef ::xml_schema::int_ maxNoEval_type;
  typedef ::xsd::cxx::tree::traits< maxNoEval_type, char > maxNoEval_traits;

  const maxNoEval_type&
  maxNoEval () const;

  maxNoEval_type&
  maxNoEval ();

  void
  maxNoEval (const maxNoEval_type& x);

  // Constructors.
  //
  SimulatedAnnealingType (const noEpsilon_type&,
                          const rt_type&,
                          const T_type&,
                          const NS_type&,
                          const NT_type&,
                          const epsilon_type&,
                          const maxNoEval_type&);

  SimulatedAnnealingType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

  SimulatedAnnealingType (const SimulatedAnnealingType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

  virtual SimulatedAnnealingType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~SimulatedAnnealingType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< noEpsilon_type > noEpsilon_;
  ::xsd::cxx::tree::one< rt_type > rt_;
  ::xsd::cxx::tree::one< T_type > T_;
  ::xsd::cxx::tree::one< NS_type > NS_;
  ::xsd::cxx::tree::one< NT_type > NT_;
  ::xsd::cxx::tree::one< epsilon_type > epsilon_;
  ::xsd::cxx::tree::one< maxNoEval_type > maxNoEval_;
};

class HybridAlgorithmType: public ::xml_schema::type
{
  public:
  // simulatedAnnealing
  // 
  typedef ::SimulatedAnnealingType simulatedAnnealing_type;
  typedef ::xsd::cxx::tree::traits< simulatedAnnealing_type, char > simulatedAnnealing_traits;

  const simulatedAnnealing_type&
  simulatedAnnealing () const;

  simulatedAnnealing_type&
  simulatedAnnealing ();

  void
  simulatedAnnealing (const simulatedAnnealing_type& x);

  void
  simulatedAnnealing (::std::auto_ptr< simulatedAnnealing_type > p);

  // Constructors.
  //
  HybridAlgorithmType (const simulatedAnnealing_type&);

  HybridAlgorithmType (::std::auto_ptr< simulatedAnnealing_type >&);

  HybridAlgorithmType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

  HybridAlgorithmType (const HybridAlgorithmType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

  virtual HybridAlgorithmType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~HybridAlgorithmType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< simulatedAnnealing_type > simulatedAnnealing_;
};

class OpenLoopType: public ::xml_schema::type
{
  public:
  // Constructors.
  //
  OpenLoopType ();

  OpenLoopType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  OpenLoopType (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  OpenLoopType (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  OpenLoopType (const OpenLoopType& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  virtual OpenLoopType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~OpenLoopType ();
};

class MuscleListType: public ::xml_schema::simple_type,
  public ::xsd::cxx::tree::list< ::xml_schema::string, char >
{
  public:
  MuscleListType ();

  MuscleListType (size_type n, const ::xml_schema::string& x);

  template < typename I >
  MuscleListType (const I& begin, const I& end)
  : ::xsd::cxx::tree::list< ::xml_schema::string, char > (begin, end, this)
  {
  }

  MuscleListType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  MuscleListType (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  MuscleListType (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  MuscleListType (const MuscleListType& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  virtual MuscleListType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~MuscleListType ();
};

class HybridType: public ::xml_schema::type
{
  public:
  // alpha
  // 
  typedef ::xml_schema::double_ alpha_type;
  typedef ::xsd::cxx::tree::traits< alpha_type, char, ::xsd::cxx::tree::schema_type::double_ > alpha_traits;

  const alpha_type&
  alpha () const;

  alpha_type&
  alpha ();

  void
  alpha (const alpha_type& x);

  // beta
  // 
  typedef ::xml_schema::double_ beta_type;
  typedef ::xsd::cxx::tree::traits< beta_type, char, ::xsd::cxx::tree::schema_type::double_ > beta_traits;

  const beta_type&
  beta () const;

  beta_type&
  beta ();

  void
  beta (const beta_type& x);

  // gamma
  // 
  typedef ::xml_schema::double_ gamma_type;
  typedef ::xsd::cxx::tree::traits< gamma_type, char, ::xsd::cxx::tree::schema_type::double_ > gamma_traits;

  const gamma_type&
  gamma () const;

  gamma_type&
  gamma ();

  void
  gamma (const gamma_type& x);

  // trackedMuscles
  // 
  typedef ::MuscleListType trackedMuscles_type;
  typedef ::xsd::cxx::tree::traits< trackedMuscles_type, char > trackedMuscles_traits;

  const trackedMuscles_type&
  trackedMuscles () const;

  trackedMuscles_type&
  trackedMuscles ();

  void
  trackedMuscles (const trackedMuscles_type& x);

  void
  trackedMuscles (::std::auto_ptr< trackedMuscles_type > p);

  // predictedMuscles
  // 
  typedef ::MuscleListType predictedMuscles_type;
  typedef ::xsd::cxx::tree::traits< predictedMuscles_type, char > predictedMuscles_traits;

  const predictedMuscles_type&
  predictedMuscles () const;

  predictedMuscles_type&
  predictedMuscles ();

  void
  predictedMuscles (const predictedMuscles_type& x);

  void
  predictedMuscles (::std::auto_ptr< predictedMuscles_type > p);

  // algorithm
  // 
  typedef ::HybridAlgorithmType algorithm_type;
  typedef ::xsd::cxx::tree::traits< algorithm_type, char > algorithm_traits;

  const algorithm_type&
  algorithm () const;

  algorithm_type&
  algorithm ();

  void
  algorithm (const algorithm_type& x);

  void
  algorithm (::std::auto_ptr< algorithm_type > p);

  // Constructors.
  //
  HybridType (const alpha_type&,
              const beta_type&,
              const gamma_type&,
              const trackedMuscles_type&,
              const predictedMuscles_type&,
              const algorithm_type&);

  HybridType (const alpha_type&,
              const beta_type&,
              const gamma_type&,
              const trackedMuscles_type&,
              const predictedMuscles_type&,
              ::std::auto_ptr< algorithm_type >&);

  HybridType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  HybridType (const HybridType& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  virtual HybridType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~HybridType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< alpha_type > alpha_;
  ::xsd::cxx::tree::one< beta_type > beta_;
  ::xsd::cxx::tree::one< gamma_type > gamma_;
  ::xsd::cxx::tree::one< trackedMuscles_type > trackedMuscles_;
  ::xsd::cxx::tree::one< predictedMuscles_type > predictedMuscles_;
  ::xsd::cxx::tree::one< algorithm_type > algorithm_;
};

class TypeType: public ::xml_schema::type
{
  public:
  // openLoop
  // 
  typedef ::OpenLoopType openLoop_type;
  typedef ::xsd::cxx::tree::optional< openLoop_type > openLoop_optional;
  typedef ::xsd::cxx::tree::traits< openLoop_type, char > openLoop_traits;

  const openLoop_optional&
  openLoop () const;

  openLoop_optional&
  openLoop ();

  void
  openLoop (const openLoop_type& x);

  void
  openLoop (const openLoop_optional& x);

  void
  openLoop (::std::auto_ptr< openLoop_type > p);

  // hybrid
  // 
  typedef ::HybridType hybrid_type;
  typedef ::xsd::cxx::tree::optional< hybrid_type > hybrid_optional;
  typedef ::xsd::cxx::tree::traits< hybrid_type, char > hybrid_traits;

  const hybrid_optional&
  hybrid () const;

  hybrid_optional&
  hybrid ();

  void
  hybrid (const hybrid_type& x);

  void
  hybrid (const hybrid_optional& x);

  void
  hybrid (::std::auto_ptr< hybrid_type > p);

  // Constructors.
  //
  TypeType ();

  TypeType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  TypeType (const TypeType& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  virtual TypeType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~TypeType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  openLoop_optional openLoop_;
  hybrid_optional hybrid_;
};

class NMSModelType: public ::xml_schema::type
{
  public:
  // type
  // 
  typedef ::TypeType type_type;
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  const type_type&
  type () const;

  type_type&
  type ();

  void
  type (const type_type& x);

  void
  type (::std::auto_ptr< type_type > p);

  // tendon
  // 
  typedef ::TendonType tendon_type;
  typedef ::xsd::cxx::tree::traits< tendon_type, char > tendon_traits;

  const tendon_type&
  tendon () const;

  tendon_type&
  tendon ();

  void
  tendon (const tendon_type& x);

  void
  tendon (::std::auto_ptr< tendon_type > p);

  // activation
  // 
  typedef ::ActivationType activation_type;
  typedef ::xsd::cxx::tree::traits< activation_type, char > activation_traits;

  const activation_type&
  activation () const;

  activation_type&
  activation ();

  void
  activation (const activation_type& x);

  void
  activation (::std::auto_ptr< activation_type > p);

  // Constructors.
  //
  NMSModelType (const type_type&,
                const tendon_type&,
                const activation_type&);

  NMSModelType (::std::auto_ptr< type_type >&,
                ::std::auto_ptr< tendon_type >&,
                ::std::auto_ptr< activation_type >&);

  NMSModelType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  NMSModelType (const NMSModelType& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  virtual NMSModelType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~NMSModelType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< type_type > type_;
  ::xsd::cxx::tree::one< tendon_type > tendon_;
  ::xsd::cxx::tree::one< activation_type > activation_;
};

class ElaboratedDoFsType: public ::xml_schema::simple_type,
  public ::xsd::cxx::tree::list< ::xml_schema::string, char >
{
  public:
  ElaboratedDoFsType ();

  ElaboratedDoFsType (size_type n, const ::xml_schema::string& x);

  template < typename I >
  ElaboratedDoFsType (const I& begin, const I& end)
  : ::xsd::cxx::tree::list< ::xml_schema::string, char > (begin, end, this)
  {
  }

  ElaboratedDoFsType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  ElaboratedDoFsType (const ::xercesc::DOMAttr& a,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  ElaboratedDoFsType (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  ElaboratedDoFsType (const ElaboratedDoFsType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  virtual ElaboratedDoFsType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~ElaboratedDoFsType ();
};

class ExecutionElementType: public ::xml_schema::type
{
  public:
  // Constructors.
  //
  ExecutionElementType ();

  ExecutionElementType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  ExecutionElementType (const ::xercesc::DOMAttr& a,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  ExecutionElementType (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  ExecutionElementType (const ExecutionElementType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  virtual ExecutionElementType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~ExecutionElementType ();
};

class FileType: public ::xml_schema::type
{
  public:
  // Constructors.
  //
  FileType ();

  FileType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  FileType (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  FileType (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  FileType (const FileType& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  virtual FileType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~FileType ();
};

class LoggingType: public ::xml_schema::type
{
  public:
  // txt
  // 
  typedef ::FileType txt_type;
  typedef ::xsd::cxx::tree::optional< txt_type > txt_optional;
  typedef ::xsd::cxx::tree::traits< txt_type, char > txt_traits;

  const txt_optional&
  txt () const;

  txt_optional&
  txt ();

  void
  txt (const txt_type& x);

  void
  txt (const txt_optional& x);

  void
  txt (::std::auto_ptr< txt_type > p);

  // csv
  // 
  typedef ::FileType csv_type;
  typedef ::xsd::cxx::tree::optional< csv_type > csv_optional;
  typedef ::xsd::cxx::tree::traits< csv_type, char > csv_traits;

  const csv_optional&
  csv () const;

  csv_optional&
  csv ();

  void
  csv (const csv_type& x);

  void
  csv (const csv_optional& x);

  void
  csv (::std::auto_ptr< csv_type > p);

  // mot
  // 
  typedef ::FileType mot_type;
  typedef ::xsd::cxx::tree::optional< mot_type > mot_optional;
  typedef ::xsd::cxx::tree::traits< mot_type, char > mot_traits;

  const mot_optional&
  mot () const;

  mot_optional&
  mot ();

  void
  mot (const mot_type& x);

  void
  mot (const mot_optional& x);

  void
  mot (::std::auto_ptr< mot_type > p);

  // Constructors.
  //
  LoggingType ();

  LoggingType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  LoggingType (const LoggingType& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  virtual LoggingType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~LoggingType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  txt_optional txt_;
  csv_optional csv_;
  mot_optional mot_;
};

class ExecutionType: public ::xml_schema::type
{
  public:
  // NMSmodel
  // 
  typedef ::NMSModelType NMSmodel_type;
  typedef ::xsd::cxx::tree::traits< NMSmodel_type, char > NMSmodel_traits;

  const NMSmodel_type&
  NMSmodel () const;

  NMSmodel_type&
  NMSmodel ();

  void
  NMSmodel (const NMSmodel_type& x);

  void
  NMSmodel (::std::auto_ptr< NMSmodel_type > p);

  // online
  // 
  typedef ::ExecutionElementType online_type;
  typedef ::xsd::cxx::tree::optional< online_type > online_optional;
  typedef ::xsd::cxx::tree::traits< online_type, char > online_traits;

  const online_optional&
  online () const;

  online_optional&
  online ();

  void
  online (const online_type& x);

  void
  online (const online_optional& x);

  void
  online (::std::auto_ptr< online_type > p);

  // offline
  // 
  typedef ::ExecutionElementType offline_type;
  typedef ::xsd::cxx::tree::optional< offline_type > offline_optional;
  typedef ::xsd::cxx::tree::traits< offline_type, char > offline_traits;

  const offline_optional&
  offline () const;

  offline_optional&
  offline ();

  void
  offline (const offline_type& x);

  void
  offline (const offline_optional& x);

  void
  offline (::std::auto_ptr< offline_type > p);

  // samplingFrequency
  // 
  typedef ::xml_schema::int_ samplingFrequency_type;
  typedef ::xsd::cxx::tree::optional< samplingFrequency_type > samplingFrequency_optional;
  typedef ::xsd::cxx::tree::traits< samplingFrequency_type, char > samplingFrequency_traits;

  const samplingFrequency_optional&
  samplingFrequency () const;

  samplingFrequency_optional&
  samplingFrequency ();

  void
  samplingFrequency (const samplingFrequency_type& x);

  void
  samplingFrequency (const samplingFrequency_optional& x);

  // elaboratedDoFs
  // 
  typedef ::ElaboratedDoFsType elaboratedDoFs_type;
  typedef ::xsd::cxx::tree::traits< elaboratedDoFs_type, char > elaboratedDoFs_traits;

  const elaboratedDoFs_type&
  elaboratedDoFs () const;

  elaboratedDoFs_type&
  elaboratedDoFs ();

  void
  elaboratedDoFs (const elaboratedDoFs_type& x);

  void
  elaboratedDoFs (::std::auto_ptr< elaboratedDoFs_type > p);

  // logging
  // 
  typedef ::LoggingType logging_type;
  typedef ::xsd::cxx::tree::traits< logging_type, char > logging_traits;

  const logging_type&
  logging () const;

  logging_type&
  logging ();

  void
  logging (const logging_type& x);

  void
  logging (::std::auto_ptr< logging_type > p);

  // Constructors.
  //
  ExecutionType (const NMSmodel_type&,
                 const elaboratedDoFs_type&,
                 const logging_type&);

  ExecutionType (::std::auto_ptr< NMSmodel_type >&,
                 const elaboratedDoFs_type&,
                 ::std::auto_ptr< logging_type >&);

  ExecutionType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  ExecutionType (const ExecutionType& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  virtual ExecutionType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~ExecutionType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< NMSmodel_type > NMSmodel_;
  online_optional online_;
  offline_optional offline_;
  samplingFrequency_optional samplingFrequency_;
  ::xsd::cxx::tree::one< elaboratedDoFs_type > elaboratedDoFs_;
  ::xsd::cxx::tree::one< logging_type > logging_;
};

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

// Parse a URI or a local file.
//

::std::auto_ptr< ::ExecutionType >
execution (const ::std::string& uri,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::ExecutionType >
execution (const ::std::string& uri,
           ::xml_schema::error_handler& eh,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::ExecutionType >
execution (const ::std::string& uri,
           ::xercesc::DOMErrorHandler& eh,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse std::istream.
//

::std::auto_ptr< ::ExecutionType >
execution (::std::istream& is,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::ExecutionType >
execution (::std::istream& is,
           ::xml_schema::error_handler& eh,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::ExecutionType >
execution (::std::istream& is,
           ::xercesc::DOMErrorHandler& eh,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::ExecutionType >
execution (::std::istream& is,
           const ::std::string& id,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::ExecutionType >
execution (::std::istream& is,
           const ::std::string& id,
           ::xml_schema::error_handler& eh,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::ExecutionType >
execution (::std::istream& is,
           const ::std::string& id,
           ::xercesc::DOMErrorHandler& eh,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse xercesc::InputSource.
//

::std::auto_ptr< ::ExecutionType >
execution (::xercesc::InputSource& is,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::ExecutionType >
execution (::xercesc::InputSource& is,
           ::xml_schema::error_handler& eh,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::ExecutionType >
execution (::xercesc::InputSource& is,
           ::xercesc::DOMErrorHandler& eh,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse xercesc::DOMDocument.
//

::std::auto_ptr< ::ExecutionType >
execution (const ::xercesc::DOMDocument& d,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::ExecutionType >
execution (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // EXECUTION_HXX
