// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "subject.hxx"

// MTUType
// 

const MTUType::name_type& MTUType::
name () const
{
  return this->name_.get ();
}

MTUType::name_type& MTUType::
name ()
{
  return this->name_.get ();
}

void MTUType::
name (const name_type& x)
{
  this->name_.set (x);
}

void MTUType::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}

const MTUType::emDelay_optional& MTUType::
emDelay () const
{
  return this->emDelay_;
}

MTUType::emDelay_optional& MTUType::
emDelay ()
{
  return this->emDelay_;
}

void MTUType::
emDelay (const emDelay_type& x)
{
  this->emDelay_.set (x);
}

void MTUType::
emDelay (const emDelay_optional& x)
{
  this->emDelay_ = x;
}

const MTUType::c1_type& MTUType::
c1 () const
{
  return this->c1_.get ();
}

MTUType::c1_type& MTUType::
c1 ()
{
  return this->c1_.get ();
}

void MTUType::
c1 (const c1_type& x)
{
  this->c1_.set (x);
}

const MTUType::c2_type& MTUType::
c2 () const
{
  return this->c2_.get ();
}

MTUType::c2_type& MTUType::
c2 ()
{
  return this->c2_.get ();
}

void MTUType::
c2 (const c2_type& x)
{
  this->c2_.set (x);
}

const MTUType::shapeFactor_type& MTUType::
shapeFactor () const
{
  return this->shapeFactor_.get ();
}

MTUType::shapeFactor_type& MTUType::
shapeFactor ()
{
  return this->shapeFactor_.get ();
}

void MTUType::
shapeFactor (const shapeFactor_type& x)
{
  this->shapeFactor_.set (x);
}

const MTUType::optimalFibreLength_type& MTUType::
optimalFibreLength () const
{
  return this->optimalFibreLength_.get ();
}

MTUType::optimalFibreLength_type& MTUType::
optimalFibreLength ()
{
  return this->optimalFibreLength_.get ();
}

void MTUType::
optimalFibreLength (const optimalFibreLength_type& x)
{
  this->optimalFibreLength_.set (x);
}

const MTUType::pennationAngle_type& MTUType::
pennationAngle () const
{
  return this->pennationAngle_.get ();
}

MTUType::pennationAngle_type& MTUType::
pennationAngle ()
{
  return this->pennationAngle_.get ();
}

void MTUType::
pennationAngle (const pennationAngle_type& x)
{
  this->pennationAngle_.set (x);
}

const MTUType::tendonSlackLength_type& MTUType::
tendonSlackLength () const
{
  return this->tendonSlackLength_.get ();
}

MTUType::tendonSlackLength_type& MTUType::
tendonSlackLength ()
{
  return this->tendonSlackLength_.get ();
}

void MTUType::
tendonSlackLength (const tendonSlackLength_type& x)
{
  this->tendonSlackLength_.set (x);
}

const MTUType::maxIsometricForce_type& MTUType::
maxIsometricForce () const
{
  return this->maxIsometricForce_.get ();
}

MTUType::maxIsometricForce_type& MTUType::
maxIsometricForce ()
{
  return this->maxIsometricForce_.get ();
}

void MTUType::
maxIsometricForce (const maxIsometricForce_type& x)
{
  this->maxIsometricForce_.set (x);
}

const MTUType::strengthCoefficient_type& MTUType::
strengthCoefficient () const
{
  return this->strengthCoefficient_.get ();
}

MTUType::strengthCoefficient_type& MTUType::
strengthCoefficient ()
{
  return this->strengthCoefficient_.get ();
}

void MTUType::
strengthCoefficient (const strengthCoefficient_type& x)
{
  this->strengthCoefficient_.set (x);
}


// MTUSetType
// 

const MTUSetType::mtu_sequence& MTUSetType::
mtu () const
{
  return this->mtu_;
}

MTUSetType::mtu_sequence& MTUSetType::
mtu ()
{
  return this->mtu_;
}

void MTUSetType::
mtu (const mtu_sequence& s)
{
  this->mtu_ = s;
}


// MTUNameSetType
//

MTUNameSetType::
MTUNameSetType ()
: ::xsd::cxx::tree::list< ::xml_schema::string, char > ( ::xml_schema::flags (0), this)
{
}

MTUNameSetType::
MTUNameSetType (size_type n, const ::xml_schema::string& x)
: ::xsd::cxx::tree::list< ::xml_schema::string, char > (n, x, this)
{
}

MTUNameSetType::
MTUNameSetType (const MTUNameSetType& o,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::simple_type (o, f, c),
  ::xsd::cxx::tree::list< ::xml_schema::string, char > (o, f, this)
{
}

// DoFType
// 

const DoFType::name_type& DoFType::
name () const
{
  return this->name_.get ();
}

DoFType::name_type& DoFType::
name ()
{
  return this->name_.get ();
}

void DoFType::
name (const name_type& x)
{
  this->name_.set (x);
}

void DoFType::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}

const DoFType::mtuNameSet_type& DoFType::
mtuNameSet () const
{
  return this->mtuNameSet_.get ();
}

DoFType::mtuNameSet_type& DoFType::
mtuNameSet ()
{
  return this->mtuNameSet_.get ();
}

void DoFType::
mtuNameSet (const mtuNameSet_type& x)
{
  this->mtuNameSet_.set (x);
}

void DoFType::
mtuNameSet (::std::auto_ptr< mtuNameSet_type > x)
{
  this->mtuNameSet_.set (x);
}


// CalibrationSequenceType
//

CalibrationSequenceType::
CalibrationSequenceType ()
: ::xsd::cxx::tree::list< ::xml_schema::string, char > ( ::xml_schema::flags (0), this)
{
}

CalibrationSequenceType::
CalibrationSequenceType (size_type n, const ::xml_schema::string& x)
: ::xsd::cxx::tree::list< ::xml_schema::string, char > (n, x, this)
{
}

CalibrationSequenceType::
CalibrationSequenceType (const CalibrationSequenceType& o,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xml_schema::simple_type (o, f, c),
  ::xsd::cxx::tree::list< ::xml_schema::string, char > (o, f, this)
{
}

// CalibratedType
// 

const CalibratedType::startSubjectFile_type& CalibratedType::
startSubjectFile () const
{
  return this->startSubjectFile_.get ();
}

CalibratedType::startSubjectFile_type& CalibratedType::
startSubjectFile ()
{
  return this->startSubjectFile_.get ();
}

void CalibratedType::
startSubjectFile (const startSubjectFile_type& x)
{
  this->startSubjectFile_.set (x);
}

void CalibratedType::
startSubjectFile (::std::auto_ptr< startSubjectFile_type > x)
{
  this->startSubjectFile_.set (x);
}

const CalibratedType::calibrationSequence_type& CalibratedType::
calibrationSequence () const
{
  return this->calibrationSequence_.get ();
}

CalibratedType::calibrationSequence_type& CalibratedType::
calibrationSequence ()
{
  return this->calibrationSequence_.get ();
}

void CalibratedType::
calibrationSequence (const calibrationSequence_type& x)
{
  this->calibrationSequence_.set (x);
}

void CalibratedType::
calibrationSequence (::std::auto_ptr< calibrationSequence_type > x)
{
  this->calibrationSequence_.set (x);
}


// UncalibratedType
// 

const UncalibratedType::subjectID_type& UncalibratedType::
subjectID () const
{
  return this->subjectID_.get ();
}

UncalibratedType::subjectID_type& UncalibratedType::
subjectID ()
{
  return this->subjectID_.get ();
}

void UncalibratedType::
subjectID (const subjectID_type& x)
{
  this->subjectID_.set (x);
}

void UncalibratedType::
subjectID (::std::auto_ptr< subjectID_type > x)
{
  this->subjectID_.set (x);
}

const UncalibratedType::additionalInfo_type& UncalibratedType::
additionalInfo () const
{
  return this->additionalInfo_.get ();
}

UncalibratedType::additionalInfo_type& UncalibratedType::
additionalInfo ()
{
  return this->additionalInfo_.get ();
}

void UncalibratedType::
additionalInfo (const additionalInfo_type& x)
{
  this->additionalInfo_.set (x);
}

void UncalibratedType::
additionalInfo (::std::auto_ptr< additionalInfo_type > x)
{
  this->additionalInfo_.set (x);
}


// CalibrationInfoType
// 

const CalibrationInfoType::uncalibrated_optional& CalibrationInfoType::
uncalibrated () const
{
  return this->uncalibrated_;
}

CalibrationInfoType::uncalibrated_optional& CalibrationInfoType::
uncalibrated ()
{
  return this->uncalibrated_;
}

void CalibrationInfoType::
uncalibrated (const uncalibrated_type& x)
{
  this->uncalibrated_.set (x);
}

void CalibrationInfoType::
uncalibrated (const uncalibrated_optional& x)
{
  this->uncalibrated_ = x;
}

void CalibrationInfoType::
uncalibrated (::std::auto_ptr< uncalibrated_type > x)
{
  this->uncalibrated_.set (x);
}

const CalibrationInfoType::calibrated_optional& CalibrationInfoType::
calibrated () const
{
  return this->calibrated_;
}

CalibrationInfoType::calibrated_optional& CalibrationInfoType::
calibrated ()
{
  return this->calibrated_;
}

void CalibrationInfoType::
calibrated (const calibrated_type& x)
{
  this->calibrated_.set (x);
}

void CalibrationInfoType::
calibrated (const calibrated_optional& x)
{
  this->calibrated_ = x;
}

void CalibrationInfoType::
calibrated (::std::auto_ptr< calibrated_type > x)
{
  this->calibrated_.set (x);
}


// DoFSetType
// 

const DoFSetType::dof_sequence& DoFSetType::
dof () const
{
  return this->dof_;
}

DoFSetType::dof_sequence& DoFSetType::
dof ()
{
  return this->dof_;
}

void DoFSetType::
dof (const dof_sequence& s)
{
  this->dof_ = s;
}


// PointsSequenceType
//

PointsSequenceType::
PointsSequenceType ()
: ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ > ( ::xml_schema::flags (0), this)
{
}

PointsSequenceType::
PointsSequenceType (size_type n, const ::xml_schema::double_& x)
: ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ > (n, x, this)
{
}

PointsSequenceType::
PointsSequenceType (const PointsSequenceType& o,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::simple_type (o, f, c),
  ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ > (o, f, this)
{
}

// CurveType
// 

const CurveType::name_type& CurveType::
name () const
{
  return this->name_.get ();
}

CurveType::name_type& CurveType::
name ()
{
  return this->name_.get ();
}

void CurveType::
name (const name_type& x)
{
  this->name_.set (x);
}

void CurveType::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}

const CurveType::xPoints_type& CurveType::
xPoints () const
{
  return this->xPoints_.get ();
}

CurveType::xPoints_type& CurveType::
xPoints ()
{
  return this->xPoints_.get ();
}

void CurveType::
xPoints (const xPoints_type& x)
{
  this->xPoints_.set (x);
}

void CurveType::
xPoints (::std::auto_ptr< xPoints_type > x)
{
  this->xPoints_.set (x);
}

const CurveType::yPoints_type& CurveType::
yPoints () const
{
  return this->yPoints_.get ();
}

CurveType::yPoints_type& CurveType::
yPoints ()
{
  return this->yPoints_.get ();
}

void CurveType::
yPoints (const yPoints_type& x)
{
  this->yPoints_.set (x);
}

void CurveType::
yPoints (::std::auto_ptr< yPoints_type > x)
{
  this->yPoints_.set (x);
}


// MTUDefaultType
// 

const MTUDefaultType::emDelay_type& MTUDefaultType::
emDelay () const
{
  return this->emDelay_.get ();
}

MTUDefaultType::emDelay_type& MTUDefaultType::
emDelay ()
{
  return this->emDelay_.get ();
}

void MTUDefaultType::
emDelay (const emDelay_type& x)
{
  this->emDelay_.set (x);
}

const MTUDefaultType::percentageChange_type& MTUDefaultType::
percentageChange () const
{
  return this->percentageChange_.get ();
}

MTUDefaultType::percentageChange_type& MTUDefaultType::
percentageChange ()
{
  return this->percentageChange_.get ();
}

void MTUDefaultType::
percentageChange (const percentageChange_type& x)
{
  this->percentageChange_.set (x);
}

const MTUDefaultType::damping_type& MTUDefaultType::
damping () const
{
  return this->damping_.get ();
}

MTUDefaultType::damping_type& MTUDefaultType::
damping ()
{
  return this->damping_.get ();
}

void MTUDefaultType::
damping (const damping_type& x)
{
  this->damping_.set (x);
}

const MTUDefaultType::curve_sequence& MTUDefaultType::
curve () const
{
  return this->curve_;
}

MTUDefaultType::curve_sequence& MTUDefaultType::
curve ()
{
  return this->curve_;
}

void MTUDefaultType::
curve (const curve_sequence& s)
{
  this->curve_ = s;
}


// SubjectType
// 

const SubjectType::mtuDefault_type& SubjectType::
mtuDefault () const
{
  return this->mtuDefault_.get ();
}

SubjectType::mtuDefault_type& SubjectType::
mtuDefault ()
{
  return this->mtuDefault_.get ();
}

void SubjectType::
mtuDefault (const mtuDefault_type& x)
{
  this->mtuDefault_.set (x);
}

void SubjectType::
mtuDefault (::std::auto_ptr< mtuDefault_type > x)
{
  this->mtuDefault_.set (x);
}

const SubjectType::mtuSet_type& SubjectType::
mtuSet () const
{
  return this->mtuSet_.get ();
}

SubjectType::mtuSet_type& SubjectType::
mtuSet ()
{
  return this->mtuSet_.get ();
}

void SubjectType::
mtuSet (const mtuSet_type& x)
{
  this->mtuSet_.set (x);
}

void SubjectType::
mtuSet (::std::auto_ptr< mtuSet_type > x)
{
  this->mtuSet_.set (x);
}

const SubjectType::dofSet_type& SubjectType::
dofSet () const
{
  return this->dofSet_.get ();
}

SubjectType::dofSet_type& SubjectType::
dofSet ()
{
  return this->dofSet_.get ();
}

void SubjectType::
dofSet (const dofSet_type& x)
{
  this->dofSet_.set (x);
}

void SubjectType::
dofSet (::std::auto_ptr< dofSet_type > x)
{
  this->dofSet_.set (x);
}

const SubjectType::calibrationInfo_type& SubjectType::
calibrationInfo () const
{
  return this->calibrationInfo_.get ();
}

SubjectType::calibrationInfo_type& SubjectType::
calibrationInfo ()
{
  return this->calibrationInfo_.get ();
}

void SubjectType::
calibrationInfo (const calibrationInfo_type& x)
{
  this->calibrationInfo_.set (x);
}

void SubjectType::
calibrationInfo (::std::auto_ptr< calibrationInfo_type > x)
{
  this->calibrationInfo_.set (x);
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// MTUType
//

MTUType::
MTUType (const name_type& name,
         const c1_type& c1,
         const c2_type& c2,
         const shapeFactor_type& shapeFactor,
         const optimalFibreLength_type& optimalFibreLength,
         const pennationAngle_type& pennationAngle,
         const tendonSlackLength_type& tendonSlackLength,
         const maxIsometricForce_type& maxIsometricForce,
         const strengthCoefficient_type& strengthCoefficient)
: ::xml_schema::type (),
  name_ (name, ::xml_schema::flags (), this),
  emDelay_ (::xml_schema::flags (), this),
  c1_ (c1, ::xml_schema::flags (), this),
  c2_ (c2, ::xml_schema::flags (), this),
  shapeFactor_ (shapeFactor, ::xml_schema::flags (), this),
  optimalFibreLength_ (optimalFibreLength, ::xml_schema::flags (), this),
  pennationAngle_ (pennationAngle, ::xml_schema::flags (), this),
  tendonSlackLength_ (tendonSlackLength, ::xml_schema::flags (), this),
  maxIsometricForce_ (maxIsometricForce, ::xml_schema::flags (), this),
  strengthCoefficient_ (strengthCoefficient, ::xml_schema::flags (), this)
{
}

MTUType::
MTUType (const MTUType& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  name_ (x.name_, f, this),
  emDelay_ (x.emDelay_, f, this),
  c1_ (x.c1_, f, this),
  c2_ (x.c2_, f, this),
  shapeFactor_ (x.shapeFactor_, f, this),
  optimalFibreLength_ (x.optimalFibreLength_, f, this),
  pennationAngle_ (x.pennationAngle_, f, this),
  tendonSlackLength_ (x.tendonSlackLength_, f, this),
  maxIsometricForce_ (x.maxIsometricForce_, f, this),
  strengthCoefficient_ (x.strengthCoefficient_, f, this)
{
}

MTUType::
MTUType (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  name_ (f, this),
  emDelay_ (f, this),
  c1_ (f, this),
  c2_ (f, this),
  shapeFactor_ (f, this),
  optimalFibreLength_ (f, this),
  pennationAngle_ (f, this),
  tendonSlackLength_ (f, this),
  maxIsometricForce_ (f, this),
  strengthCoefficient_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void MTUType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // name
    //
    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< name_type > r (
        name_traits::create (i, f, this));

      if (!name_.present ())
      {
        this->name_.set (r);
        continue;
      }
    }

    // emDelay
    //
    if (n.name () == "emDelay" && n.namespace_ ().empty ())
    {
      if (!this->emDelay_)
      {
        this->emDelay_.set (emDelay_traits::create (i, f, this));
        continue;
      }
    }

    // c1
    //
    if (n.name () == "c1" && n.namespace_ ().empty ())
    {
      if (!c1_.present ())
      {
        this->c1_.set (c1_traits::create (i, f, this));
        continue;
      }
    }

    // c2
    //
    if (n.name () == "c2" && n.namespace_ ().empty ())
    {
      if (!c2_.present ())
      {
        this->c2_.set (c2_traits::create (i, f, this));
        continue;
      }
    }

    // shapeFactor
    //
    if (n.name () == "shapeFactor" && n.namespace_ ().empty ())
    {
      if (!shapeFactor_.present ())
      {
        this->shapeFactor_.set (shapeFactor_traits::create (i, f, this));
        continue;
      }
    }

    // optimalFibreLength
    //
    if (n.name () == "optimalFibreLength" && n.namespace_ ().empty ())
    {
      if (!optimalFibreLength_.present ())
      {
        this->optimalFibreLength_.set (optimalFibreLength_traits::create (i, f, this));
        continue;
      }
    }

    // pennationAngle
    //
    if (n.name () == "pennationAngle" && n.namespace_ ().empty ())
    {
      if (!pennationAngle_.present ())
      {
        this->pennationAngle_.set (pennationAngle_traits::create (i, f, this));
        continue;
      }
    }

    // tendonSlackLength
    //
    if (n.name () == "tendonSlackLength" && n.namespace_ ().empty ())
    {
      if (!tendonSlackLength_.present ())
      {
        this->tendonSlackLength_.set (tendonSlackLength_traits::create (i, f, this));
        continue;
      }
    }

    // maxIsometricForce
    //
    if (n.name () == "maxIsometricForce" && n.namespace_ ().empty ())
    {
      if (!maxIsometricForce_.present ())
      {
        this->maxIsometricForce_.set (maxIsometricForce_traits::create (i, f, this));
        continue;
      }
    }

    // strengthCoefficient
    //
    if (n.name () == "strengthCoefficient" && n.namespace_ ().empty ())
    {
      if (!strengthCoefficient_.present ())
      {
        this->strengthCoefficient_.set (strengthCoefficient_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!name_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "name",
      "");
  }

  if (!c1_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "c1",
      "");
  }

  if (!c2_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "c2",
      "");
  }

  if (!shapeFactor_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "shapeFactor",
      "");
  }

  if (!optimalFibreLength_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "optimalFibreLength",
      "");
  }

  if (!pennationAngle_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "pennationAngle",
      "");
  }

  if (!tendonSlackLength_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "tendonSlackLength",
      "");
  }

  if (!maxIsometricForce_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "maxIsometricForce",
      "");
  }

  if (!strengthCoefficient_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "strengthCoefficient",
      "");
  }
}

MTUType* MTUType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class MTUType (*this, f, c);
}

MTUType::
~MTUType ()
{
}

// MTUSetType
//

MTUSetType::
MTUSetType ()
: ::xml_schema::type (),
  mtu_ (::xml_schema::flags (), this)
{
}

MTUSetType::
MTUSetType (const MTUSetType& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  mtu_ (x.mtu_, f, this)
{
}

MTUSetType::
MTUSetType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  mtu_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void MTUSetType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // mtu
    //
    if (n.name () == "mtu" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< mtu_type > r (
        mtu_traits::create (i, f, this));

      this->mtu_.push_back (r);
      continue;
    }

    break;
  }
}

MTUSetType* MTUSetType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class MTUSetType (*this, f, c);
}

MTUSetType::
~MTUSetType ()
{
}

// MTUNameSetType
//

MTUNameSetType::
MTUNameSetType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::simple_type (e, f, c),
  ::xsd::cxx::tree::list< ::xml_schema::string, char > (e, f, this)
{
}

MTUNameSetType::
MTUNameSetType (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::simple_type (a, f, c),
  ::xsd::cxx::tree::list< ::xml_schema::string, char > (a, f, this)
{
}

MTUNameSetType::
MTUNameSetType (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::simple_type (s, e, f, c),
  ::xsd::cxx::tree::list< ::xml_schema::string, char > (s, e, f, this)
{
}

MTUNameSetType* MTUNameSetType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class MTUNameSetType (*this, f, c);
}

MTUNameSetType::
~MTUNameSetType ()
{
}

// DoFType
//

DoFType::
DoFType (const name_type& name,
         const mtuNameSet_type& mtuNameSet)
: ::xml_schema::type (),
  name_ (name, ::xml_schema::flags (), this),
  mtuNameSet_ (mtuNameSet, ::xml_schema::flags (), this)
{
}

DoFType::
DoFType (const DoFType& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  name_ (x.name_, f, this),
  mtuNameSet_ (x.mtuNameSet_, f, this)
{
}

DoFType::
DoFType (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  name_ (f, this),
  mtuNameSet_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void DoFType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // name
    //
    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< name_type > r (
        name_traits::create (i, f, this));

      if (!name_.present ())
      {
        this->name_.set (r);
        continue;
      }
    }

    // mtuNameSet
    //
    if (n.name () == "mtuNameSet" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< mtuNameSet_type > r (
        mtuNameSet_traits::create (i, f, this));

      if (!mtuNameSet_.present ())
      {
        this->mtuNameSet_.set (r);
        continue;
      }
    }

    break;
  }

  if (!name_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "name",
      "");
  }

  if (!mtuNameSet_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "mtuNameSet",
      "");
  }
}

DoFType* DoFType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class DoFType (*this, f, c);
}

DoFType::
~DoFType ()
{
}

// CalibrationSequenceType
//

CalibrationSequenceType::
CalibrationSequenceType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xml_schema::simple_type (e, f, c),
  ::xsd::cxx::tree::list< ::xml_schema::string, char > (e, f, this)
{
}

CalibrationSequenceType::
CalibrationSequenceType (const ::xercesc::DOMAttr& a,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xml_schema::simple_type (a, f, c),
  ::xsd::cxx::tree::list< ::xml_schema::string, char > (a, f, this)
{
}

CalibrationSequenceType::
CalibrationSequenceType (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xml_schema::simple_type (s, e, f, c),
  ::xsd::cxx::tree::list< ::xml_schema::string, char > (s, e, f, this)
{
}

CalibrationSequenceType* CalibrationSequenceType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class CalibrationSequenceType (*this, f, c);
}

CalibrationSequenceType::
~CalibrationSequenceType ()
{
}

// CalibratedType
//

CalibratedType::
CalibratedType (const startSubjectFile_type& startSubjectFile,
                const calibrationSequence_type& calibrationSequence)
: ::xml_schema::type (),
  startSubjectFile_ (startSubjectFile, ::xml_schema::flags (), this),
  calibrationSequence_ (calibrationSequence, ::xml_schema::flags (), this)
{
}

CalibratedType::
CalibratedType (const CalibratedType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  startSubjectFile_ (x.startSubjectFile_, f, this),
  calibrationSequence_ (x.calibrationSequence_, f, this)
{
}

CalibratedType::
CalibratedType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  startSubjectFile_ (f, this),
  calibrationSequence_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void CalibratedType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // startSubjectFile
    //
    if (n.name () == "startSubjectFile" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< startSubjectFile_type > r (
        startSubjectFile_traits::create (i, f, this));

      if (!startSubjectFile_.present ())
      {
        this->startSubjectFile_.set (r);
        continue;
      }
    }

    // calibrationSequence
    //
    if (n.name () == "calibrationSequence" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< calibrationSequence_type > r (
        calibrationSequence_traits::create (i, f, this));

      if (!calibrationSequence_.present ())
      {
        this->calibrationSequence_.set (r);
        continue;
      }
    }

    break;
  }

  if (!startSubjectFile_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "startSubjectFile",
      "");
  }

  if (!calibrationSequence_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "calibrationSequence",
      "");
  }
}

CalibratedType* CalibratedType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class CalibratedType (*this, f, c);
}

CalibratedType::
~CalibratedType ()
{
}

// UncalibratedType
//

UncalibratedType::
UncalibratedType (const subjectID_type& subjectID,
                  const additionalInfo_type& additionalInfo)
: ::xml_schema::type (),
  subjectID_ (subjectID, ::xml_schema::flags (), this),
  additionalInfo_ (additionalInfo, ::xml_schema::flags (), this)
{
}

UncalibratedType::
UncalibratedType (const UncalibratedType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  subjectID_ (x.subjectID_, f, this),
  additionalInfo_ (x.additionalInfo_, f, this)
{
}

UncalibratedType::
UncalibratedType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  subjectID_ (f, this),
  additionalInfo_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void UncalibratedType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // subjectID
    //
    if (n.name () == "subjectID" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< subjectID_type > r (
        subjectID_traits::create (i, f, this));

      if (!subjectID_.present ())
      {
        this->subjectID_.set (r);
        continue;
      }
    }

    // additionalInfo
    //
    if (n.name () == "additionalInfo" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< additionalInfo_type > r (
        additionalInfo_traits::create (i, f, this));

      if (!additionalInfo_.present ())
      {
        this->additionalInfo_.set (r);
        continue;
      }
    }

    break;
  }

  if (!subjectID_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "subjectID",
      "");
  }

  if (!additionalInfo_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "additionalInfo",
      "");
  }
}

UncalibratedType* UncalibratedType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class UncalibratedType (*this, f, c);
}

UncalibratedType::
~UncalibratedType ()
{
}

// CalibrationInfoType
//

CalibrationInfoType::
CalibrationInfoType ()
: ::xml_schema::type (),
  uncalibrated_ (::xml_schema::flags (), this),
  calibrated_ (::xml_schema::flags (), this)
{
}

CalibrationInfoType::
CalibrationInfoType (const CalibrationInfoType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  uncalibrated_ (x.uncalibrated_, f, this),
  calibrated_ (x.calibrated_, f, this)
{
}

CalibrationInfoType::
CalibrationInfoType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  uncalibrated_ (f, this),
  calibrated_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void CalibrationInfoType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // uncalibrated
    //
    if (n.name () == "uncalibrated" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< uncalibrated_type > r (
        uncalibrated_traits::create (i, f, this));

      if (!this->uncalibrated_)
      {
        this->uncalibrated_.set (r);
        continue;
      }
    }

    // calibrated
    //
    if (n.name () == "calibrated" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< calibrated_type > r (
        calibrated_traits::create (i, f, this));

      if (!this->calibrated_)
      {
        this->calibrated_.set (r);
        continue;
      }
    }

    break;
  }
}

CalibrationInfoType* CalibrationInfoType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class CalibrationInfoType (*this, f, c);
}

CalibrationInfoType::
~CalibrationInfoType ()
{
}

// DoFSetType
//

DoFSetType::
DoFSetType ()
: ::xml_schema::type (),
  dof_ (::xml_schema::flags (), this)
{
}

DoFSetType::
DoFSetType (const DoFSetType& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  dof_ (x.dof_, f, this)
{
}

DoFSetType::
DoFSetType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  dof_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void DoFSetType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // dof
    //
    if (n.name () == "dof" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< dof_type > r (
        dof_traits::create (i, f, this));

      this->dof_.push_back (r);
      continue;
    }

    break;
  }
}

DoFSetType* DoFSetType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class DoFSetType (*this, f, c);
}

DoFSetType::
~DoFSetType ()
{
}

// PointsSequenceType
//

PointsSequenceType::
PointsSequenceType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::simple_type (e, f, c),
  ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ > (e, f, this)
{
}

PointsSequenceType::
PointsSequenceType (const ::xercesc::DOMAttr& a,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::simple_type (a, f, c),
  ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ > (a, f, this)
{
}

PointsSequenceType::
PointsSequenceType (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::simple_type (s, e, f, c),
  ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ > (s, e, f, this)
{
}

PointsSequenceType* PointsSequenceType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class PointsSequenceType (*this, f, c);
}

PointsSequenceType::
~PointsSequenceType ()
{
}

// CurveType
//

CurveType::
CurveType (const name_type& name,
           const xPoints_type& xPoints,
           const yPoints_type& yPoints)
: ::xml_schema::type (),
  name_ (name, ::xml_schema::flags (), this),
  xPoints_ (xPoints, ::xml_schema::flags (), this),
  yPoints_ (yPoints, ::xml_schema::flags (), this)
{
}

CurveType::
CurveType (const CurveType& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  name_ (x.name_, f, this),
  xPoints_ (x.xPoints_, f, this),
  yPoints_ (x.yPoints_, f, this)
{
}

CurveType::
CurveType (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  name_ (f, this),
  xPoints_ (f, this),
  yPoints_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void CurveType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // name
    //
    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< name_type > r (
        name_traits::create (i, f, this));

      if (!name_.present ())
      {
        this->name_.set (r);
        continue;
      }
    }

    // xPoints
    //
    if (n.name () == "xPoints" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< xPoints_type > r (
        xPoints_traits::create (i, f, this));

      if (!xPoints_.present ())
      {
        this->xPoints_.set (r);
        continue;
      }
    }

    // yPoints
    //
    if (n.name () == "yPoints" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< yPoints_type > r (
        yPoints_traits::create (i, f, this));

      if (!yPoints_.present ())
      {
        this->yPoints_.set (r);
        continue;
      }
    }

    break;
  }

  if (!name_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "name",
      "");
  }

  if (!xPoints_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "xPoints",
      "");
  }

  if (!yPoints_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "yPoints",
      "");
  }
}

CurveType* CurveType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class CurveType (*this, f, c);
}

CurveType::
~CurveType ()
{
}

// MTUDefaultType
//

MTUDefaultType::
MTUDefaultType (const emDelay_type& emDelay,
                const percentageChange_type& percentageChange,
                const damping_type& damping)
: ::xml_schema::type (),
  emDelay_ (emDelay, ::xml_schema::flags (), this),
  percentageChange_ (percentageChange, ::xml_schema::flags (), this),
  damping_ (damping, ::xml_schema::flags (), this),
  curve_ (::xml_schema::flags (), this)
{
}

MTUDefaultType::
MTUDefaultType (const MTUDefaultType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  emDelay_ (x.emDelay_, f, this),
  percentageChange_ (x.percentageChange_, f, this),
  damping_ (x.damping_, f, this),
  curve_ (x.curve_, f, this)
{
}

MTUDefaultType::
MTUDefaultType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  emDelay_ (f, this),
  percentageChange_ (f, this),
  damping_ (f, this),
  curve_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void MTUDefaultType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // emDelay
    //
    if (n.name () == "emDelay" && n.namespace_ ().empty ())
    {
      if (!emDelay_.present ())
      {
        this->emDelay_.set (emDelay_traits::create (i, f, this));
        continue;
      }
    }

    // percentageChange
    //
    if (n.name () == "percentageChange" && n.namespace_ ().empty ())
    {
      if (!percentageChange_.present ())
      {
        this->percentageChange_.set (percentageChange_traits::create (i, f, this));
        continue;
      }
    }

    // damping
    //
    if (n.name () == "damping" && n.namespace_ ().empty ())
    {
      if (!damping_.present ())
      {
        this->damping_.set (damping_traits::create (i, f, this));
        continue;
      }
    }

    // curve
    //
    if (n.name () == "curve" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< curve_type > r (
        curve_traits::create (i, f, this));

      this->curve_.push_back (r);
      continue;
    }

    break;
  }

  if (!emDelay_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "emDelay",
      "");
  }

  if (!percentageChange_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "percentageChange",
      "");
  }

  if (!damping_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "damping",
      "");
  }
}

MTUDefaultType* MTUDefaultType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class MTUDefaultType (*this, f, c);
}

MTUDefaultType::
~MTUDefaultType ()
{
}

// SubjectType
//

SubjectType::
SubjectType (const mtuDefault_type& mtuDefault,
             const mtuSet_type& mtuSet,
             const dofSet_type& dofSet,
             const calibrationInfo_type& calibrationInfo)
: ::xml_schema::type (),
  mtuDefault_ (mtuDefault, ::xml_schema::flags (), this),
  mtuSet_ (mtuSet, ::xml_schema::flags (), this),
  dofSet_ (dofSet, ::xml_schema::flags (), this),
  calibrationInfo_ (calibrationInfo, ::xml_schema::flags (), this)
{
}

SubjectType::
SubjectType (::std::auto_ptr< mtuDefault_type >& mtuDefault,
             ::std::auto_ptr< mtuSet_type >& mtuSet,
             ::std::auto_ptr< dofSet_type >& dofSet,
             ::std::auto_ptr< calibrationInfo_type >& calibrationInfo)
: ::xml_schema::type (),
  mtuDefault_ (mtuDefault, ::xml_schema::flags (), this),
  mtuSet_ (mtuSet, ::xml_schema::flags (), this),
  dofSet_ (dofSet, ::xml_schema::flags (), this),
  calibrationInfo_ (calibrationInfo, ::xml_schema::flags (), this)
{
}

SubjectType::
SubjectType (const SubjectType& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  mtuDefault_ (x.mtuDefault_, f, this),
  mtuSet_ (x.mtuSet_, f, this),
  dofSet_ (x.dofSet_, f, this),
  calibrationInfo_ (x.calibrationInfo_, f, this)
{
}

SubjectType::
SubjectType (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  mtuDefault_ (f, this),
  mtuSet_ (f, this),
  dofSet_ (f, this),
  calibrationInfo_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void SubjectType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // mtuDefault
    //
    if (n.name () == "mtuDefault" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< mtuDefault_type > r (
        mtuDefault_traits::create (i, f, this));

      if (!mtuDefault_.present ())
      {
        this->mtuDefault_.set (r);
        continue;
      }
    }

    // mtuSet
    //
    if (n.name () == "mtuSet" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< mtuSet_type > r (
        mtuSet_traits::create (i, f, this));

      if (!mtuSet_.present ())
      {
        this->mtuSet_.set (r);
        continue;
      }
    }

    // dofSet
    //
    if (n.name () == "dofSet" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< dofSet_type > r (
        dofSet_traits::create (i, f, this));

      if (!dofSet_.present ())
      {
        this->dofSet_.set (r);
        continue;
      }
    }

    // calibrationInfo
    //
    if (n.name () == "calibrationInfo" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< calibrationInfo_type > r (
        calibrationInfo_traits::create (i, f, this));

      if (!calibrationInfo_.present ())
      {
        this->calibrationInfo_.set (r);
        continue;
      }
    }

    break;
  }

  if (!mtuDefault_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "mtuDefault",
      "");
  }

  if (!mtuSet_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "mtuSet",
      "");
  }

  if (!dofSet_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "dofSet",
      "");
  }

  if (!calibrationInfo_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "calibrationInfo",
      "");
  }
}

SubjectType* SubjectType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class SubjectType (*this, f, c);
}

SubjectType::
~SubjectType ()
{
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::auto_ptr< ::SubjectType >
subject (const ::std::string& u,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::SubjectType > r (
    ::subject (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::SubjectType >
subject (const ::std::string& u,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::SubjectType > r (
    ::subject (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::SubjectType >
subject (const ::std::string& u,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::SubjectType > r (
    ::subject (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::SubjectType >
subject (::std::istream& is,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::subject (isrc, f, p);
}

::std::auto_ptr< ::SubjectType >
subject (::std::istream& is,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::subject (isrc, h, f, p);
}

::std::auto_ptr< ::SubjectType >
subject (::std::istream& is,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::subject (isrc, h, f, p);
}

::std::auto_ptr< ::SubjectType >
subject (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::subject (isrc, f, p);
}

::std::auto_ptr< ::SubjectType >
subject (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::subject (isrc, h, f, p);
}

::std::auto_ptr< ::SubjectType >
subject (::std::istream& is,
         const ::std::string& sid,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::subject (isrc, h, f, p);
}

::std::auto_ptr< ::SubjectType >
subject (::xercesc::InputSource& i,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::SubjectType > r (
    ::subject (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::SubjectType >
subject (::xercesc::InputSource& i,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::SubjectType > r (
    ::subject (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::SubjectType >
subject (::xercesc::InputSource& i,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::SubjectType > r (
    ::subject (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::SubjectType >
subject (const ::xercesc::DOMDocument& d,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

    ::std::auto_ptr< ::SubjectType > r (
      ::subject (
        c, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  const ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "subject" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::SubjectType > r (
      ::xsd::cxx::tree::traits< ::SubjectType, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "subject",
    "");
}

::std::auto_ptr< ::SubjectType >
subject (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
         ::xml_schema::flags f,
         const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "subject" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::SubjectType > r (
      ::xsd::cxx::tree::traits< ::SubjectType, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "subject",
    "");
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

void
operator<< (::xercesc::DOMElement& e, const MTUType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // name
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "name",
        e));

    s << i.name ();
  }

  // emDelay
  //
  if (i.emDelay ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "emDelay",
        e));

    s << ::xml_schema::as_double(*i.emDelay ());
  }

  // c1
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "c1",
        e));

    s << ::xml_schema::as_double(i.c1 ());
  }

  // c2
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "c2",
        e));

    s << ::xml_schema::as_double(i.c2 ());
  }

  // shapeFactor
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "shapeFactor",
        e));

    s << ::xml_schema::as_double(i.shapeFactor ());
  }

  // optimalFibreLength
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "optimalFibreLength",
        e));

    s << ::xml_schema::as_double(i.optimalFibreLength ());
  }

  // pennationAngle
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "pennationAngle",
        e));

    s << ::xml_schema::as_double(i.pennationAngle ());
  }

  // tendonSlackLength
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "tendonSlackLength",
        e));

    s << ::xml_schema::as_double(i.tendonSlackLength ());
  }

  // maxIsometricForce
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "maxIsometricForce",
        e));

    s << ::xml_schema::as_double(i.maxIsometricForce ());
  }

  // strengthCoefficient
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "strengthCoefficient",
        e));

    s << ::xml_schema::as_double(i.strengthCoefficient ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const MTUSetType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // mtu
  //
  for (MTUSetType::mtu_const_iterator
       b (i.mtu ().begin ()), n (i.mtu ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "mtu",
        e));

    s << *b;
  }
}

void
operator<< (::xercesc::DOMElement& e, const MTUNameSetType& i)
{
  e << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::string, char >& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const MTUNameSetType& i)
{
  a << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::string, char >& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const MTUNameSetType& i)
{
  l << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::string, char >& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const DoFType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // name
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "name",
        e));

    s << i.name ();
  }

  // mtuNameSet
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "mtuNameSet",
        e));

    s << i.mtuNameSet ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const CalibrationSequenceType& i)
{
  e << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::string, char >& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const CalibrationSequenceType& i)
{
  a << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::string, char >& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const CalibrationSequenceType& i)
{
  l << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::string, char >& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const CalibratedType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // startSubjectFile
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "startSubjectFile",
        e));

    s << i.startSubjectFile ();
  }

  // calibrationSequence
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "calibrationSequence",
        e));

    s << i.calibrationSequence ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const UncalibratedType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // subjectID
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "subjectID",
        e));

    s << i.subjectID ();
  }

  // additionalInfo
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "additionalInfo",
        e));

    s << i.additionalInfo ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const CalibrationInfoType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // uncalibrated
  //
  if (i.uncalibrated ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "uncalibrated",
        e));

    s << *i.uncalibrated ();
  }

  // calibrated
  //
  if (i.calibrated ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "calibrated",
        e));

    s << *i.calibrated ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const DoFSetType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // dof
  //
  for (DoFSetType::dof_const_iterator
       b (i.dof ().begin ()), n (i.dof ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dof",
        e));

    s << *b;
  }
}

void
operator<< (::xercesc::DOMElement& e, const PointsSequenceType& i)
{
  e << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ >& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const PointsSequenceType& i)
{
  a << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ >& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const PointsSequenceType& i)
{
  l << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ >& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const CurveType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // name
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "name",
        e));

    s << i.name ();
  }

  // xPoints
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "xPoints",
        e));

    s << i.xPoints ();
  }

  // yPoints
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "yPoints",
        e));

    s << i.yPoints ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const MTUDefaultType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // emDelay
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "emDelay",
        e));

    s << ::xml_schema::as_double(i.emDelay ());
  }

  // percentageChange
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "percentageChange",
        e));

    s << ::xml_schema::as_double(i.percentageChange ());
  }

  // damping
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "damping",
        e));

    s << ::xml_schema::as_double(i.damping ());
  }

  // curve
  //
  for (MTUDefaultType::curve_const_iterator
       b (i.curve ().begin ()), n (i.curve ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "curve",
        e));

    s << *b;
  }
}

void
operator<< (::xercesc::DOMElement& e, const SubjectType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // mtuDefault
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "mtuDefault",
        e));

    s << i.mtuDefault ();
  }

  // mtuSet
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "mtuSet",
        e));

    s << i.mtuSet ();
  }

  // dofSet
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dofSet",
        e));

    s << i.dofSet ();
  }

  // calibrationInfo
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "calibrationInfo",
        e));

    s << i.calibrationInfo ();
  }
}

void
subject (::std::ostream& o,
         const ::SubjectType& s,
         const ::xml_schema::namespace_infomap& m,
         const ::std::string& e,
         ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::subject (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
subject (::std::ostream& o,
         const ::SubjectType& s,
         ::xml_schema::error_handler& h,
         const ::xml_schema::namespace_infomap& m,
         const ::std::string& e,
         ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::subject (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
subject (::std::ostream& o,
         const ::SubjectType& s,
         ::xercesc::DOMErrorHandler& h,
         const ::xml_schema::namespace_infomap& m,
         const ::std::string& e,
         ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::subject (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
subject (::xercesc::XMLFormatTarget& t,
         const ::SubjectType& s,
         const ::xml_schema::namespace_infomap& m,
         const ::std::string& e,
         ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::subject (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
subject (::xercesc::XMLFormatTarget& t,
         const ::SubjectType& s,
         ::xml_schema::error_handler& h,
         const ::xml_schema::namespace_infomap& m,
         const ::std::string& e,
         ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::subject (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
subject (::xercesc::XMLFormatTarget& t,
         const ::SubjectType& s,
         ::xercesc::DOMErrorHandler& h,
         const ::xml_schema::namespace_infomap& m,
         const ::std::string& e,
         ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::subject (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
subject (::xercesc::DOMDocument& d,
         const ::SubjectType& s,
         ::xml_schema::flags)
{
  ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "subject" &&
      n.namespace_ () == "")
  {
    e << s;
  }
  else
  {
    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "subject",
      "");
  }
}

::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
subject (const ::SubjectType& s,
         const ::xml_schema::namespace_infomap& m,
         ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::serialize< char > (
      "subject",
      "",
      m, f));

  ::subject (*d, s, f);
  return d;
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

