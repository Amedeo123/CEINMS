// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "calibration.hxx"

namespace CalibrationXsd
{
  // SimulatedAnnealingType
  // 

  const SimulatedAnnealingType::noEpsilon_type& SimulatedAnnealingType::
  noEpsilon () const
  {
    return this->noEpsilon_.get ();
  }

  SimulatedAnnealingType::noEpsilon_type& SimulatedAnnealingType::
  noEpsilon ()
  {
    return this->noEpsilon_.get ();
  }

  void SimulatedAnnealingType::
  noEpsilon (const noEpsilon_type& x)
  {
    this->noEpsilon_.set (x);
  }

  const SimulatedAnnealingType::rt_type& SimulatedAnnealingType::
  rt () const
  {
    return this->rt_.get ();
  }

  SimulatedAnnealingType::rt_type& SimulatedAnnealingType::
  rt ()
  {
    return this->rt_.get ();
  }

  void SimulatedAnnealingType::
  rt (const rt_type& x)
  {
    this->rt_.set (x);
  }

  const SimulatedAnnealingType::T_type& SimulatedAnnealingType::
  T () const
  {
    return this->T_.get ();
  }

  SimulatedAnnealingType::T_type& SimulatedAnnealingType::
  T ()
  {
    return this->T_.get ();
  }

  void SimulatedAnnealingType::
  T (const T_type& x)
  {
    this->T_.set (x);
  }

  const SimulatedAnnealingType::NS_type& SimulatedAnnealingType::
  NS () const
  {
    return this->NS_.get ();
  }

  SimulatedAnnealingType::NS_type& SimulatedAnnealingType::
  NS ()
  {
    return this->NS_.get ();
  }

  void SimulatedAnnealingType::
  NS (const NS_type& x)
  {
    this->NS_.set (x);
  }

  const SimulatedAnnealingType::NT_type& SimulatedAnnealingType::
  NT () const
  {
    return this->NT_.get ();
  }

  SimulatedAnnealingType::NT_type& SimulatedAnnealingType::
  NT ()
  {
    return this->NT_.get ();
  }

  void SimulatedAnnealingType::
  NT (const NT_type& x)
  {
    this->NT_.set (x);
  }

  const SimulatedAnnealingType::epsilon_type& SimulatedAnnealingType::
  epsilon () const
  {
    return this->epsilon_.get ();
  }

  SimulatedAnnealingType::epsilon_type& SimulatedAnnealingType::
  epsilon ()
  {
    return this->epsilon_.get ();
  }

  void SimulatedAnnealingType::
  epsilon (const epsilon_type& x)
  {
    this->epsilon_.set (x);
  }

  const SimulatedAnnealingType::maxNoEval_type& SimulatedAnnealingType::
  maxNoEval () const
  {
    return this->maxNoEval_.get ();
  }

  SimulatedAnnealingType::maxNoEval_type& SimulatedAnnealingType::
  maxNoEval ()
  {
    return this->maxNoEval_.get ();
  }

  void SimulatedAnnealingType::
  maxNoEval (const maxNoEval_type& x)
  {
    this->maxNoEval_.set (x);
  }


  // AlgorithmType
  // 

  const AlgorithmType::simulatedAnnealing_type& AlgorithmType::
  simulatedAnnealing () const
  {
    return this->simulatedAnnealing_.get ();
  }

  AlgorithmType::simulatedAnnealing_type& AlgorithmType::
  simulatedAnnealing ()
  {
    return this->simulatedAnnealing_.get ();
  }

  void AlgorithmType::
  simulatedAnnealing (const simulatedAnnealing_type& x)
  {
    this->simulatedAnnealing_.set (x);
  }

  void AlgorithmType::
  simulatedAnnealing (::std::auto_ptr< simulatedAnnealing_type > x)
  {
    this->simulatedAnnealing_.set (x);
  }


  // OpenLoopType
  // 


  // TypeType
  // 

  const TypeType::openLoop_type& TypeType::
  openLoop () const
  {
    return this->openLoop_.get ();
  }

  TypeType::openLoop_type& TypeType::
  openLoop ()
  {
    return this->openLoop_.get ();
  }

  void TypeType::
  openLoop (const openLoop_type& x)
  {
    this->openLoop_.set (x);
  }

  void TypeType::
  openLoop (::std::auto_ptr< openLoop_type > x)
  {
    this->openLoop_.set (x);
  }


  // TendonElementType
  // 


  // TendonType
  // 

  const TendonType::stiff_optional& TendonType::
  stiff () const
  {
    return this->stiff_;
  }

  TendonType::stiff_optional& TendonType::
  stiff ()
  {
    return this->stiff_;
  }

  void TendonType::
  stiff (const stiff_type& x)
  {
    this->stiff_.set (x);
  }

  void TendonType::
  stiff (const stiff_optional& x)
  {
    this->stiff_ = x;
  }

  void TendonType::
  stiff (::std::auto_ptr< stiff_type > x)
  {
    this->stiff_.set (x);
  }

  const TendonType::elastic_optional& TendonType::
  elastic () const
  {
    return this->elastic_;
  }

  TendonType::elastic_optional& TendonType::
  elastic ()
  {
    return this->elastic_;
  }

  void TendonType::
  elastic (const elastic_type& x)
  {
    this->elastic_.set (x);
  }

  void TendonType::
  elastic (const elastic_optional& x)
  {
    this->elastic_ = x;
  }

  void TendonType::
  elastic (::std::auto_ptr< elastic_type > x)
  {
    this->elastic_.set (x);
  }

  const TendonType::elasticBiSec_optional& TendonType::
  elasticBiSec () const
  {
    return this->elasticBiSec_;
  }

  TendonType::elasticBiSec_optional& TendonType::
  elasticBiSec ()
  {
    return this->elasticBiSec_;
  }

  void TendonType::
  elasticBiSec (const elasticBiSec_type& x)
  {
    this->elasticBiSec_.set (x);
  }

  void TendonType::
  elasticBiSec (const elasticBiSec_optional& x)
  {
    this->elasticBiSec_ = x;
  }

  void TendonType::
  elasticBiSec (::std::auto_ptr< elasticBiSec_type > x)
  {
    this->elasticBiSec_.set (x);
  }


  // ActivationElementType
  // 


  // ActivationType
  // 

  const ActivationType::exponential_optional& ActivationType::
  exponential () const
  {
    return this->exponential_;
  }

  ActivationType::exponential_optional& ActivationType::
  exponential ()
  {
    return this->exponential_;
  }

  void ActivationType::
  exponential (const exponential_type& x)
  {
    this->exponential_.set (x);
  }

  void ActivationType::
  exponential (const exponential_optional& x)
  {
    this->exponential_ = x;
  }

  void ActivationType::
  exponential (::std::auto_ptr< exponential_type > x)
  {
    this->exponential_.set (x);
  }

  const ActivationType::piecewise_optional& ActivationType::
  piecewise () const
  {
    return this->piecewise_;
  }

  ActivationType::piecewise_optional& ActivationType::
  piecewise ()
  {
    return this->piecewise_;
  }

  void ActivationType::
  piecewise (const piecewise_type& x)
  {
    this->piecewise_.set (x);
  }

  void ActivationType::
  piecewise (const piecewise_optional& x)
  {
    this->piecewise_ = x;
  }

  void ActivationType::
  piecewise (::std::auto_ptr< piecewise_type > x)
  {
    this->piecewise_.set (x);
  }


  // NMSModelType
  // 

  const NMSModelType::type_type& NMSModelType::
  type () const
  {
    return this->type_.get ();
  }

  NMSModelType::type_type& NMSModelType::
  type ()
  {
    return this->type_.get ();
  }

  void NMSModelType::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void NMSModelType::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }

  const NMSModelType::tendon_type& NMSModelType::
  tendon () const
  {
    return this->tendon_.get ();
  }

  NMSModelType::tendon_type& NMSModelType::
  tendon ()
  {
    return this->tendon_.get ();
  }

  void NMSModelType::
  tendon (const tendon_type& x)
  {
    this->tendon_.set (x);
  }

  void NMSModelType::
  tendon (::std::auto_ptr< tendon_type > x)
  {
    this->tendon_.set (x);
  }

  const NMSModelType::activation_type& NMSModelType::
  activation () const
  {
    return this->activation_.get ();
  }

  NMSModelType::activation_type& NMSModelType::
  activation ()
  {
    return this->activation_.get ();
  }

  void NMSModelType::
  activation (const activation_type& x)
  {
    this->activation_.set (x);
  }

  void NMSModelType::
  activation (::std::auto_ptr< activation_type > x)
  {
    this->activation_.set (x);
  }


  // TrialSetType
  //

  TrialSetType::
  TrialSetType ()
  : ::xsd::cxx::tree::list< ::xml_schema::string, char > ( ::xml_schema::flags (0), this)
  {
  }

  TrialSetType::
  TrialSetType (size_type n, const ::xml_schema::string& x)
  : ::xsd::cxx::tree::list< ::xml_schema::string, char > (n, x, this)
  {
  }

  TrialSetType::
  TrialSetType (const TrialSetType& o,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::simple_type (o, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::string, char > (o, f, this)
  {
  }

  // ObjectiveFunctionElementType
  // 


  // ComputationModeElementType
  // 


  // GlobalParameterType
  // 


  // SingleParameterType
  // 


  // ObjectiveFunctionType
  // 

  const ObjectiveFunctionType::minimizeTorqueError_type& ObjectiveFunctionType::
  minimizeTorqueError () const
  {
    return this->minimizeTorqueError_.get ();
  }

  ObjectiveFunctionType::minimizeTorqueError_type& ObjectiveFunctionType::
  minimizeTorqueError ()
  {
    return this->minimizeTorqueError_.get ();
  }

  void ObjectiveFunctionType::
  minimizeTorqueError (const minimizeTorqueError_type& x)
  {
    this->minimizeTorqueError_.set (x);
  }

  void ObjectiveFunctionType::
  minimizeTorqueError (::std::auto_ptr< minimizeTorqueError_type > x)
  {
    this->minimizeTorqueError_.set (x);
  }


  // DoFsType
  //

  DoFsType::
  DoFsType ()
  : ::xsd::cxx::tree::list< ::xml_schema::string, char > ( ::xml_schema::flags (0), this)
  {
  }

  DoFsType::
  DoFsType (size_type n, const ::xml_schema::string& x)
  : ::xsd::cxx::tree::list< ::xml_schema::string, char > (n, x, this)
  {
  }

  DoFsType::
  DoFsType (const DoFsType& o,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::simple_type (o, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::string, char > (o, f, this)
  {
  }

  // HardCodedParametersSelectionType
  // 


  // ComputationModeType
  // 

  const ComputationModeType::default_optional& ComputationModeType::
  default_ () const
  {
    return this->default__;
  }

  ComputationModeType::default_optional& ComputationModeType::
  default_ ()
  {
    return this->default__;
  }

  void ComputationModeType::
  default_ (const default_type& x)
  {
    this->default__.set (x);
  }

  void ComputationModeType::
  default_ (const default_optional& x)
  {
    this->default__ = x;
  }

  void ComputationModeType::
  default_ (::std::auto_ptr< default_type > x)
  {
    this->default__.set (x);
  }

  const ComputationModeType::fast_optional& ComputationModeType::
  fast () const
  {
    return this->fast_;
  }

  ComputationModeType::fast_optional& ComputationModeType::
  fast ()
  {
    return this->fast_;
  }

  void ComputationModeType::
  fast (const fast_type& x)
  {
    this->fast_.set (x);
  }

  void ComputationModeType::
  fast (const fast_optional& x)
  {
    this->fast_ = x;
  }

  void ComputationModeType::
  fast (::std::auto_ptr< fast_type > x)
  {
    this->fast_.set (x);
  }


  // TwoDoublesType
  //

  TwoDoublesType::
  TwoDoublesType ()
  : ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ > ( ::xml_schema::flags (0), this)
  {
  }

  TwoDoublesType::
  TwoDoublesType (size_type n, const ::xml_schema::double_& x)
  : ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ > (n, x, this)
  {
  }

  TwoDoublesType::
  TwoDoublesType (const TwoDoublesType& o,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::simple_type (o, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ > (o, f, this)
  {
  }

  // RangeType
  // 

  const RangeType::range_type& RangeType::
  range () const
  {
    return this->range_.get ();
  }

  RangeType::range_type& RangeType::
  range ()
  {
    return this->range_.get ();
  }

  void RangeType::
  range (const range_type& x)
  {
    this->range_.set (x);
  }

  void RangeType::
  range (::std::auto_ptr< range_type > x)
  {
    this->range_.set (x);
  }


  // MuscleListType
  //

  MuscleListType::
  MuscleListType ()
  : ::xsd::cxx::tree::list< ::xml_schema::string, char > ( ::xml_schema::flags (0), this)
  {
  }

  MuscleListType::
  MuscleListType (size_type n, const ::xml_schema::string& x)
  : ::xsd::cxx::tree::list< ::xml_schema::string, char > (n, x, this)
  {
  }

  MuscleListType::
  MuscleListType (const MuscleListType& o,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::simple_type (o, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::string, char > (o, f, this)
  {
  }

  // MuscleGroupsType
  // 

  const MuscleGroupsType::muscles_sequence& MuscleGroupsType::
  muscles () const
  {
    return this->muscles_;
  }

  MuscleGroupsType::muscles_sequence& MuscleGroupsType::
  muscles ()
  {
    return this->muscles_;
  }

  void MuscleGroupsType::
  muscles (const muscles_sequence& s)
  {
    this->muscles_ = s;
  }


  // ParameterType
  // 

  const ParameterType::name_type& ParameterType::
  name () const
  {
    return this->name_.get ();
  }

  ParameterType::name_type& ParameterType::
  name ()
  {
    return this->name_.get ();
  }

  void ParameterType::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void ParameterType::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const ParameterType::muscleGroups_optional& ParameterType::
  muscleGroups () const
  {
    return this->muscleGroups_;
  }

  ParameterType::muscleGroups_optional& ParameterType::
  muscleGroups ()
  {
    return this->muscleGroups_;
  }

  void ParameterType::
  muscleGroups (const muscleGroups_type& x)
  {
    this->muscleGroups_.set (x);
  }

  void ParameterType::
  muscleGroups (const muscleGroups_optional& x)
  {
    this->muscleGroups_ = x;
  }

  void ParameterType::
  muscleGroups (::std::auto_ptr< muscleGroups_type > x)
  {
    this->muscleGroups_.set (x);
  }

  const ParameterType::global_optional& ParameterType::
  global () const
  {
    return this->global_;
  }

  ParameterType::global_optional& ParameterType::
  global ()
  {
    return this->global_;
  }

  void ParameterType::
  global (const global_type& x)
  {
    this->global_.set (x);
  }

  void ParameterType::
  global (const global_optional& x)
  {
    this->global_ = x;
  }

  void ParameterType::
  global (::std::auto_ptr< global_type > x)
  {
    this->global_.set (x);
  }

  const ParameterType::single_optional& ParameterType::
  single () const
  {
    return this->single_;
  }

  ParameterType::single_optional& ParameterType::
  single ()
  {
    return this->single_;
  }

  void ParameterType::
  single (const single_type& x)
  {
    this->single_.set (x);
  }

  void ParameterType::
  single (const single_optional& x)
  {
    this->single_ = x;
  }

  void ParameterType::
  single (::std::auto_ptr< single_type > x)
  {
    this->single_.set (x);
  }

  const ParameterType::absolute_optional& ParameterType::
  absolute () const
  {
    return this->absolute_;
  }

  ParameterType::absolute_optional& ParameterType::
  absolute ()
  {
    return this->absolute_;
  }

  void ParameterType::
  absolute (const absolute_type& x)
  {
    this->absolute_.set (x);
  }

  void ParameterType::
  absolute (const absolute_optional& x)
  {
    this->absolute_ = x;
  }

  void ParameterType::
  absolute (::std::auto_ptr< absolute_type > x)
  {
    this->absolute_.set (x);
  }

  const ParameterType::relativeToSubjectValue_optional& ParameterType::
  relativeToSubjectValue () const
  {
    return this->relativeToSubjectValue_;
  }

  ParameterType::relativeToSubjectValue_optional& ParameterType::
  relativeToSubjectValue ()
  {
    return this->relativeToSubjectValue_;
  }

  void ParameterType::
  relativeToSubjectValue (const relativeToSubjectValue_type& x)
  {
    this->relativeToSubjectValue_.set (x);
  }

  void ParameterType::
  relativeToSubjectValue (const relativeToSubjectValue_optional& x)
  {
    this->relativeToSubjectValue_ = x;
  }

  void ParameterType::
  relativeToSubjectValue (::std::auto_ptr< relativeToSubjectValue_type > x)
  {
    this->relativeToSubjectValue_.set (x);
  }


  // parameterSetType
  // 

  const parameterSetType::parameter_sequence& parameterSetType::
  parameter () const
  {
    return this->parameter_;
  }

  parameterSetType::parameter_sequence& parameterSetType::
  parameter ()
  {
    return this->parameter_;
  }

  void parameterSetType::
  parameter (const parameter_sequence& s)
  {
    this->parameter_ = s;
  }


  // StepType
  // 

  const StepType::dofs_type& StepType::
  dofs () const
  {
    return this->dofs_.get ();
  }

  StepType::dofs_type& StepType::
  dofs ()
  {
    return this->dofs_.get ();
  }

  void StepType::
  dofs (const dofs_type& x)
  {
    this->dofs_.set (x);
  }

  void StepType::
  dofs (::std::auto_ptr< dofs_type > x)
  {
    this->dofs_.set (x);
  }

  const StepType::objectiveFunction_type& StepType::
  objectiveFunction () const
  {
    return this->objectiveFunction_.get ();
  }

  StepType::objectiveFunction_type& StepType::
  objectiveFunction ()
  {
    return this->objectiveFunction_.get ();
  }

  void StepType::
  objectiveFunction (const objectiveFunction_type& x)
  {
    this->objectiveFunction_.set (x);
  }

  void StepType::
  objectiveFunction (::std::auto_ptr< objectiveFunction_type > x)
  {
    this->objectiveFunction_.set (x);
  }

  const StepType::computationMode_type& StepType::
  computationMode () const
  {
    return this->computationMode_.get ();
  }

  StepType::computationMode_type& StepType::
  computationMode ()
  {
    return this->computationMode_.get ();
  }

  void StepType::
  computationMode (const computationMode_type& x)
  {
    this->computationMode_.set (x);
  }

  void StepType::
  computationMode (::std::auto_ptr< computationMode_type > x)
  {
    this->computationMode_.set (x);
  }

  const StepType::strengthCoefficients_ShapeFactor_C1_C2_TendonSLackLength_single_optional& StepType::
  strengthCoefficients_ShapeFactor_C1_C2_TendonSLackLength_single () const
  {
    return this->strengthCoefficients_ShapeFactor_C1_C2_TendonSLackLength_single_;
  }

  StepType::strengthCoefficients_ShapeFactor_C1_C2_TendonSLackLength_single_optional& StepType::
  strengthCoefficients_ShapeFactor_C1_C2_TendonSLackLength_single ()
  {
    return this->strengthCoefficients_ShapeFactor_C1_C2_TendonSLackLength_single_;
  }

  void StepType::
  strengthCoefficients_ShapeFactor_C1_C2_TendonSLackLength_single (const strengthCoefficients_ShapeFactor_C1_C2_TendonSLackLength_single_type& x)
  {
    this->strengthCoefficients_ShapeFactor_C1_C2_TendonSLackLength_single_.set (x);
  }

  void StepType::
  strengthCoefficients_ShapeFactor_C1_C2_TendonSLackLength_single (const strengthCoefficients_ShapeFactor_C1_C2_TendonSLackLength_single_optional& x)
  {
    this->strengthCoefficients_ShapeFactor_C1_C2_TendonSLackLength_single_ = x;
  }

  void StepType::
  strengthCoefficients_ShapeFactor_C1_C2_TendonSLackLength_single (::std::auto_ptr< strengthCoefficients_ShapeFactor_C1_C2_TendonSLackLength_single_type > x)
  {
    this->strengthCoefficients_ShapeFactor_C1_C2_TendonSLackLength_single_.set (x);
  }

  const StepType::parameterSet_optional& StepType::
  parameterSet () const
  {
    return this->parameterSet_;
  }

  StepType::parameterSet_optional& StepType::
  parameterSet ()
  {
    return this->parameterSet_;
  }

  void StepType::
  parameterSet (const parameterSet_type& x)
  {
    this->parameterSet_.set (x);
  }

  void StepType::
  parameterSet (const parameterSet_optional& x)
  {
    this->parameterSet_ = x;
  }

  void StepType::
  parameterSet (::std::auto_ptr< parameterSet_type > x)
  {
    this->parameterSet_.set (x);
  }


  // CalibrationStepsType
  // 

  const CalibrationStepsType::step_sequence& CalibrationStepsType::
  step () const
  {
    return this->step_;
  }

  CalibrationStepsType::step_sequence& CalibrationStepsType::
  step ()
  {
    return this->step_;
  }

  void CalibrationStepsType::
  step (const step_sequence& s)
  {
    this->step_ = s;
  }


  // CalibrationType
  // 

  const CalibrationType::algorithm_type& CalibrationType::
  algorithm () const
  {
    return this->algorithm_.get ();
  }

  CalibrationType::algorithm_type& CalibrationType::
  algorithm ()
  {
    return this->algorithm_.get ();
  }

  void CalibrationType::
  algorithm (const algorithm_type& x)
  {
    this->algorithm_.set (x);
  }

  void CalibrationType::
  algorithm (::std::auto_ptr< algorithm_type > x)
  {
    this->algorithm_.set (x);
  }

  const CalibrationType::NMSmodel_type& CalibrationType::
  NMSmodel () const
  {
    return this->NMSmodel_.get ();
  }

  CalibrationType::NMSmodel_type& CalibrationType::
  NMSmodel ()
  {
    return this->NMSmodel_.get ();
  }

  void CalibrationType::
  NMSmodel (const NMSmodel_type& x)
  {
    this->NMSmodel_.set (x);
  }

  void CalibrationType::
  NMSmodel (::std::auto_ptr< NMSmodel_type > x)
  {
    this->NMSmodel_.set (x);
  }

  const CalibrationType::samplingFrequency_optional& CalibrationType::
  samplingFrequency () const
  {
    return this->samplingFrequency_;
  }

  CalibrationType::samplingFrequency_optional& CalibrationType::
  samplingFrequency ()
  {
    return this->samplingFrequency_;
  }

  void CalibrationType::
  samplingFrequency (const samplingFrequency_type& x)
  {
    this->samplingFrequency_.set (x);
  }

  void CalibrationType::
  samplingFrequency (const samplingFrequency_optional& x)
  {
    this->samplingFrequency_ = x;
  }

  const CalibrationType::calibrationSteps_type& CalibrationType::
  calibrationSteps () const
  {
    return this->calibrationSteps_.get ();
  }

  CalibrationType::calibrationSteps_type& CalibrationType::
  calibrationSteps ()
  {
    return this->calibrationSteps_.get ();
  }

  void CalibrationType::
  calibrationSteps (const calibrationSteps_type& x)
  {
    this->calibrationSteps_.set (x);
  }

  void CalibrationType::
  calibrationSteps (::std::auto_ptr< calibrationSteps_type > x)
  {
    this->calibrationSteps_.set (x);
  }

  const CalibrationType::trialsDirectory_type& CalibrationType::
  trialsDirectory () const
  {
    return this->trialsDirectory_.get ();
  }

  CalibrationType::trialsDirectory_type& CalibrationType::
  trialsDirectory ()
  {
    return this->trialsDirectory_.get ();
  }

  void CalibrationType::
  trialsDirectory (const trialsDirectory_type& x)
  {
    this->trialsDirectory_.set (x);
  }

  void CalibrationType::
  trialsDirectory (::std::auto_ptr< trialsDirectory_type > x)
  {
    this->trialsDirectory_.set (x);
  }

  const CalibrationType::trialSet_type& CalibrationType::
  trialSet () const
  {
    return this->trialSet_.get ();
  }

  CalibrationType::trialSet_type& CalibrationType::
  trialSet ()
  {
    return this->trialSet_.get ();
  }

  void CalibrationType::
  trialSet (const trialSet_type& x)
  {
    this->trialSet_.set (x);
  }

  void CalibrationType::
  trialSet (::std::auto_ptr< trialSet_type > x)
  {
    this->trialSet_.set (x);
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace CalibrationXsd
{
  // SimulatedAnnealingType
  //

  SimulatedAnnealingType::
  SimulatedAnnealingType (const noEpsilon_type& noEpsilon,
                          const rt_type& rt,
                          const T_type& T,
                          const NS_type& NS,
                          const NT_type& NT,
                          const epsilon_type& epsilon,
                          const maxNoEval_type& maxNoEval)
  : ::xml_schema::type (),
    noEpsilon_ (noEpsilon, ::xml_schema::flags (), this),
    rt_ (rt, ::xml_schema::flags (), this),
    T_ (T, ::xml_schema::flags (), this),
    NS_ (NS, ::xml_schema::flags (), this),
    NT_ (NT, ::xml_schema::flags (), this),
    epsilon_ (epsilon, ::xml_schema::flags (), this),
    maxNoEval_ (maxNoEval, ::xml_schema::flags (), this)
  {
  }

  SimulatedAnnealingType::
  SimulatedAnnealingType (const SimulatedAnnealingType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    noEpsilon_ (x.noEpsilon_, f, this),
    rt_ (x.rt_, f, this),
    T_ (x.T_, f, this),
    NS_ (x.NS_, f, this),
    NT_ (x.NT_, f, this),
    epsilon_ (x.epsilon_, f, this),
    maxNoEval_ (x.maxNoEval_, f, this)
  {
  }

  SimulatedAnnealingType::
  SimulatedAnnealingType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    noEpsilon_ (f, this),
    rt_ (f, this),
    T_ (f, this),
    NS_ (f, this),
    NT_ (f, this),
    epsilon_ (f, this),
    maxNoEval_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void SimulatedAnnealingType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // noEpsilon
      //
      if (n.name () == "noEpsilon" && n.namespace_ ().empty ())
      {
        if (!noEpsilon_.present ())
        {
          this->noEpsilon_.set (noEpsilon_traits::create (i, f, this));
          continue;
        }
      }

      // rt
      //
      if (n.name () == "rt" && n.namespace_ ().empty ())
      {
        if (!rt_.present ())
        {
          this->rt_.set (rt_traits::create (i, f, this));
          continue;
        }
      }

      // T
      //
      if (n.name () == "T" && n.namespace_ ().empty ())
      {
        if (!T_.present ())
        {
          this->T_.set (T_traits::create (i, f, this));
          continue;
        }
      }

      // NS
      //
      if (n.name () == "NS" && n.namespace_ ().empty ())
      {
        if (!NS_.present ())
        {
          this->NS_.set (NS_traits::create (i, f, this));
          continue;
        }
      }

      // NT
      //
      if (n.name () == "NT" && n.namespace_ ().empty ())
      {
        if (!NT_.present ())
        {
          this->NT_.set (NT_traits::create (i, f, this));
          continue;
        }
      }

      // epsilon
      //
      if (n.name () == "epsilon" && n.namespace_ ().empty ())
      {
        if (!epsilon_.present ())
        {
          this->epsilon_.set (epsilon_traits::create (i, f, this));
          continue;
        }
      }

      // maxNoEval
      //
      if (n.name () == "maxNoEval" && n.namespace_ ().empty ())
      {
        if (!maxNoEval_.present ())
        {
          this->maxNoEval_.set (maxNoEval_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!noEpsilon_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "noEpsilon",
        "");
    }

    if (!rt_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "rt",
        "");
    }

    if (!T_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "T",
        "");
    }

    if (!NS_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "NS",
        "");
    }

    if (!NT_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "NT",
        "");
    }

    if (!epsilon_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "epsilon",
        "");
    }

    if (!maxNoEval_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "maxNoEval",
        "");
    }
  }

  SimulatedAnnealingType* SimulatedAnnealingType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class SimulatedAnnealingType (*this, f, c);
  }

  SimulatedAnnealingType::
  ~SimulatedAnnealingType ()
  {
  }

  // AlgorithmType
  //

  AlgorithmType::
  AlgorithmType (const simulatedAnnealing_type& simulatedAnnealing)
  : ::xml_schema::type (),
    simulatedAnnealing_ (simulatedAnnealing, ::xml_schema::flags (), this)
  {
  }

  AlgorithmType::
  AlgorithmType (::std::auto_ptr< simulatedAnnealing_type >& simulatedAnnealing)
  : ::xml_schema::type (),
    simulatedAnnealing_ (simulatedAnnealing, ::xml_schema::flags (), this)
  {
  }

  AlgorithmType::
  AlgorithmType (const AlgorithmType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    simulatedAnnealing_ (x.simulatedAnnealing_, f, this)
  {
  }

  AlgorithmType::
  AlgorithmType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    simulatedAnnealing_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void AlgorithmType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // simulatedAnnealing
      //
      if (n.name () == "simulatedAnnealing" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< simulatedAnnealing_type > r (
          simulatedAnnealing_traits::create (i, f, this));

        if (!simulatedAnnealing_.present ())
        {
          this->simulatedAnnealing_.set (r);
          continue;
        }
      }

      break;
    }

    if (!simulatedAnnealing_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "simulatedAnnealing",
        "");
    }
  }

  AlgorithmType* AlgorithmType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class AlgorithmType (*this, f, c);
  }

  AlgorithmType::
  ~AlgorithmType ()
  {
  }

  // OpenLoopType
  //

  OpenLoopType::
  OpenLoopType ()
  : ::xml_schema::type ()
  {
  }

  OpenLoopType::
  OpenLoopType (const OpenLoopType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c)
  {
  }

  OpenLoopType::
  OpenLoopType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f, c)
  {
  }

  OpenLoopType::
  OpenLoopType (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (a, f, c)
  {
  }

  OpenLoopType::
  OpenLoopType (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (s, e, f, c)
  {
  }

  OpenLoopType* OpenLoopType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class OpenLoopType (*this, f, c);
  }

  OpenLoopType::
  ~OpenLoopType ()
  {
  }

  // TypeType
  //

  TypeType::
  TypeType (const openLoop_type& openLoop)
  : ::xml_schema::type (),
    openLoop_ (openLoop, ::xml_schema::flags (), this)
  {
  }

  TypeType::
  TypeType (const TypeType& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    openLoop_ (x.openLoop_, f, this)
  {
  }

  TypeType::
  TypeType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    openLoop_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void TypeType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // openLoop
      //
      if (n.name () == "openLoop" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< openLoop_type > r (
          openLoop_traits::create (i, f, this));

        if (!openLoop_.present ())
        {
          this->openLoop_.set (r);
          continue;
        }
      }

      break;
    }

    if (!openLoop_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "openLoop",
        "");
    }
  }

  TypeType* TypeType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class TypeType (*this, f, c);
  }

  TypeType::
  ~TypeType ()
  {
  }

  // TendonElementType
  //

  TendonElementType::
  TendonElementType ()
  : ::xml_schema::type ()
  {
  }

  TendonElementType::
  TendonElementType (const TendonElementType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c)
  {
  }

  TendonElementType::
  TendonElementType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (e, f, c)
  {
  }

  TendonElementType::
  TendonElementType (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (a, f, c)
  {
  }

  TendonElementType::
  TendonElementType (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (s, e, f, c)
  {
  }

  TendonElementType* TendonElementType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class TendonElementType (*this, f, c);
  }

  TendonElementType::
  ~TendonElementType ()
  {
  }

  // TendonType
  //

  TendonType::
  TendonType ()
  : ::xml_schema::type (),
    stiff_ (::xml_schema::flags (), this),
    elastic_ (::xml_schema::flags (), this),
    elasticBiSec_ (::xml_schema::flags (), this)
  {
  }

  TendonType::
  TendonType (const TendonType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    stiff_ (x.stiff_, f, this),
    elastic_ (x.elastic_, f, this),
    elasticBiSec_ (x.elasticBiSec_, f, this)
  {
  }

  TendonType::
  TendonType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    stiff_ (f, this),
    elastic_ (f, this),
    elasticBiSec_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void TendonType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // stiff
      //
      if (n.name () == "stiff" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< stiff_type > r (
          stiff_traits::create (i, f, this));

        if (!this->stiff_)
        {
          this->stiff_.set (r);
          continue;
        }
      }

      // elastic
      //
      if (n.name () == "elastic" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< elastic_type > r (
          elastic_traits::create (i, f, this));

        if (!this->elastic_)
        {
          this->elastic_.set (r);
          continue;
        }
      }

      // elasticBiSec
      //
      if (n.name () == "elasticBiSec" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< elasticBiSec_type > r (
          elasticBiSec_traits::create (i, f, this));

        if (!this->elasticBiSec_)
        {
          this->elasticBiSec_.set (r);
          continue;
        }
      }

      break;
    }
  }

  TendonType* TendonType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class TendonType (*this, f, c);
  }

  TendonType::
  ~TendonType ()
  {
  }

  // ActivationElementType
  //

  ActivationElementType::
  ActivationElementType ()
  : ::xml_schema::type ()
  {
  }

  ActivationElementType::
  ActivationElementType (const ActivationElementType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c)
  {
  }

  ActivationElementType::
  ActivationElementType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::type (e, f, c)
  {
  }

  ActivationElementType::
  ActivationElementType (const ::xercesc::DOMAttr& a,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::type (a, f, c)
  {
  }

  ActivationElementType::
  ActivationElementType (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::type (s, e, f, c)
  {
  }

  ActivationElementType* ActivationElementType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ActivationElementType (*this, f, c);
  }

  ActivationElementType::
  ~ActivationElementType ()
  {
  }

  // ActivationType
  //

  ActivationType::
  ActivationType ()
  : ::xml_schema::type (),
    exponential_ (::xml_schema::flags (), this),
    piecewise_ (::xml_schema::flags (), this)
  {
  }

  ActivationType::
  ActivationType (const ActivationType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    exponential_ (x.exponential_, f, this),
    piecewise_ (x.piecewise_, f, this)
  {
  }

  ActivationType::
  ActivationType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    exponential_ (f, this),
    piecewise_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void ActivationType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // exponential
      //
      if (n.name () == "exponential" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< exponential_type > r (
          exponential_traits::create (i, f, this));

        if (!this->exponential_)
        {
          this->exponential_.set (r);
          continue;
        }
      }

      // piecewise
      //
      if (n.name () == "piecewise" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< piecewise_type > r (
          piecewise_traits::create (i, f, this));

        if (!this->piecewise_)
        {
          this->piecewise_.set (r);
          continue;
        }
      }

      break;
    }
  }

  ActivationType* ActivationType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ActivationType (*this, f, c);
  }

  ActivationType::
  ~ActivationType ()
  {
  }

  // NMSModelType
  //

  NMSModelType::
  NMSModelType (const type_type& type,
                const tendon_type& tendon,
                const activation_type& activation)
  : ::xml_schema::type (),
    type_ (type, ::xml_schema::flags (), this),
    tendon_ (tendon, ::xml_schema::flags (), this),
    activation_ (activation, ::xml_schema::flags (), this)
  {
  }

  NMSModelType::
  NMSModelType (::std::auto_ptr< type_type >& type,
                ::std::auto_ptr< tendon_type >& tendon,
                ::std::auto_ptr< activation_type >& activation)
  : ::xml_schema::type (),
    type_ (type, ::xml_schema::flags (), this),
    tendon_ (tendon, ::xml_schema::flags (), this),
    activation_ (activation, ::xml_schema::flags (), this)
  {
  }

  NMSModelType::
  NMSModelType (const NMSModelType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    type_ (x.type_, f, this),
    tendon_ (x.tendon_, f, this),
    activation_ (x.activation_, f, this)
  {
  }

  NMSModelType::
  NMSModelType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    type_ (f, this),
    tendon_ (f, this),
    activation_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void NMSModelType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // type
      //
      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< type_type > r (
          type_traits::create (i, f, this));

        if (!type_.present ())
        {
          this->type_.set (r);
          continue;
        }
      }

      // tendon
      //
      if (n.name () == "tendon" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< tendon_type > r (
          tendon_traits::create (i, f, this));

        if (!tendon_.present ())
        {
          this->tendon_.set (r);
          continue;
        }
      }

      // activation
      //
      if (n.name () == "activation" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< activation_type > r (
          activation_traits::create (i, f, this));

        if (!activation_.present ())
        {
          this->activation_.set (r);
          continue;
        }
      }

      break;
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "type",
        "");
    }

    if (!tendon_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "tendon",
        "");
    }

    if (!activation_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "activation",
        "");
    }
  }

  NMSModelType* NMSModelType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class NMSModelType (*this, f, c);
  }

  NMSModelType::
  ~NMSModelType ()
  {
  }

  // TrialSetType
  //

  TrialSetType::
  TrialSetType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::simple_type (e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::string, char > (e, f, this)
  {
  }

  TrialSetType::
  TrialSetType (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::simple_type (a, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::string, char > (a, f, this)
  {
  }

  TrialSetType::
  TrialSetType (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::simple_type (s, e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::string, char > (s, e, f, this)
  {
  }

  TrialSetType* TrialSetType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class TrialSetType (*this, f, c);
  }

  TrialSetType::
  ~TrialSetType ()
  {
  }

  // ObjectiveFunctionElementType
  //

  ObjectiveFunctionElementType::
  ObjectiveFunctionElementType ()
  : ::xml_schema::type ()
  {
  }

  ObjectiveFunctionElementType::
  ObjectiveFunctionElementType (const ObjectiveFunctionElementType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c)
  {
  }

  ObjectiveFunctionElementType::
  ObjectiveFunctionElementType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
  : ::xml_schema::type (e, f, c)
  {
  }

  ObjectiveFunctionElementType::
  ObjectiveFunctionElementType (const ::xercesc::DOMAttr& a,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
  : ::xml_schema::type (a, f, c)
  {
  }

  ObjectiveFunctionElementType::
  ObjectiveFunctionElementType (const ::std::string& s,
                                const ::xercesc::DOMElement* e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
  : ::xml_schema::type (s, e, f, c)
  {
  }

  ObjectiveFunctionElementType* ObjectiveFunctionElementType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ObjectiveFunctionElementType (*this, f, c);
  }

  ObjectiveFunctionElementType::
  ~ObjectiveFunctionElementType ()
  {
  }

  // ComputationModeElementType
  //

  ComputationModeElementType::
  ComputationModeElementType ()
  : ::xml_schema::type ()
  {
  }

  ComputationModeElementType::
  ComputationModeElementType (const ComputationModeElementType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c)
  {
  }

  ComputationModeElementType::
  ComputationModeElementType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
  : ::xml_schema::type (e, f, c)
  {
  }

  ComputationModeElementType::
  ComputationModeElementType (const ::xercesc::DOMAttr& a,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
  : ::xml_schema::type (a, f, c)
  {
  }

  ComputationModeElementType::
  ComputationModeElementType (const ::std::string& s,
                              const ::xercesc::DOMElement* e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
  : ::xml_schema::type (s, e, f, c)
  {
  }

  ComputationModeElementType* ComputationModeElementType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ComputationModeElementType (*this, f, c);
  }

  ComputationModeElementType::
  ~ComputationModeElementType ()
  {
  }

  // GlobalParameterType
  //

  GlobalParameterType::
  GlobalParameterType ()
  : ::xml_schema::type ()
  {
  }

  GlobalParameterType::
  GlobalParameterType (const GlobalParameterType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c)
  {
  }

  GlobalParameterType::
  GlobalParameterType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (e, f, c)
  {
  }

  GlobalParameterType::
  GlobalParameterType (const ::xercesc::DOMAttr& a,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (a, f, c)
  {
  }

  GlobalParameterType::
  GlobalParameterType (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (s, e, f, c)
  {
  }

  GlobalParameterType* GlobalParameterType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class GlobalParameterType (*this, f, c);
  }

  GlobalParameterType::
  ~GlobalParameterType ()
  {
  }

  // SingleParameterType
  //

  SingleParameterType::
  SingleParameterType ()
  : ::xml_schema::type ()
  {
  }

  SingleParameterType::
  SingleParameterType (const SingleParameterType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c)
  {
  }

  SingleParameterType::
  SingleParameterType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (e, f, c)
  {
  }

  SingleParameterType::
  SingleParameterType (const ::xercesc::DOMAttr& a,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (a, f, c)
  {
  }

  SingleParameterType::
  SingleParameterType (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (s, e, f, c)
  {
  }

  SingleParameterType* SingleParameterType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class SingleParameterType (*this, f, c);
  }

  SingleParameterType::
  ~SingleParameterType ()
  {
  }

  // ObjectiveFunctionType
  //

  ObjectiveFunctionType::
  ObjectiveFunctionType (const minimizeTorqueError_type& minimizeTorqueError)
  : ::xml_schema::type (),
    minimizeTorqueError_ (minimizeTorqueError, ::xml_schema::flags (), this)
  {
  }

  ObjectiveFunctionType::
  ObjectiveFunctionType (const ObjectiveFunctionType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    minimizeTorqueError_ (x.minimizeTorqueError_, f, this)
  {
  }

  ObjectiveFunctionType::
  ObjectiveFunctionType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    minimizeTorqueError_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void ObjectiveFunctionType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // minimizeTorqueError
      //
      if (n.name () == "minimizeTorqueError" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< minimizeTorqueError_type > r (
          minimizeTorqueError_traits::create (i, f, this));

        if (!minimizeTorqueError_.present ())
        {
          this->minimizeTorqueError_.set (r);
          continue;
        }
      }

      break;
    }

    if (!minimizeTorqueError_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "minimizeTorqueError",
        "");
    }
  }

  ObjectiveFunctionType* ObjectiveFunctionType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ObjectiveFunctionType (*this, f, c);
  }

  ObjectiveFunctionType::
  ~ObjectiveFunctionType ()
  {
  }

  // DoFsType
  //

  DoFsType::
  DoFsType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::simple_type (e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::string, char > (e, f, this)
  {
  }

  DoFsType::
  DoFsType (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::simple_type (a, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::string, char > (a, f, this)
  {
  }

  DoFsType::
  DoFsType (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::simple_type (s, e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::string, char > (s, e, f, this)
  {
  }

  DoFsType* DoFsType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DoFsType (*this, f, c);
  }

  DoFsType::
  ~DoFsType ()
  {
  }

  // HardCodedParametersSelectionType
  //

  HardCodedParametersSelectionType::
  HardCodedParametersSelectionType ()
  : ::xml_schema::type ()
  {
  }

  HardCodedParametersSelectionType::
  HardCodedParametersSelectionType (const HardCodedParametersSelectionType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c)
  {
  }

  HardCodedParametersSelectionType::
  HardCodedParametersSelectionType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f, c)
  {
  }

  HardCodedParametersSelectionType::
  HardCodedParametersSelectionType (const ::xercesc::DOMAttr& a,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
  : ::xml_schema::type (a, f, c)
  {
  }

  HardCodedParametersSelectionType::
  HardCodedParametersSelectionType (const ::std::string& s,
                                    const ::xercesc::DOMElement* e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
  : ::xml_schema::type (s, e, f, c)
  {
  }

  HardCodedParametersSelectionType* HardCodedParametersSelectionType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class HardCodedParametersSelectionType (*this, f, c);
  }

  HardCodedParametersSelectionType::
  ~HardCodedParametersSelectionType ()
  {
  }

  // ComputationModeType
  //

  ComputationModeType::
  ComputationModeType ()
  : ::xml_schema::type (),
    default__ (::xml_schema::flags (), this),
    fast_ (::xml_schema::flags (), this)
  {
  }

  ComputationModeType::
  ComputationModeType (const ComputationModeType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    default__ (x.default__, f, this),
    fast_ (x.fast_, f, this)
  {
  }

  ComputationModeType::
  ComputationModeType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    default__ (f, this),
    fast_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void ComputationModeType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // default
      //
      if (n.name () == "default" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< default_type > r (
          default_traits::create (i, f, this));

        if (!this->default__)
        {
          this->default__.set (r);
          continue;
        }
      }

      // fast
      //
      if (n.name () == "fast" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< fast_type > r (
          fast_traits::create (i, f, this));

        if (!this->fast_)
        {
          this->fast_.set (r);
          continue;
        }
      }

      break;
    }
  }

  ComputationModeType* ComputationModeType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ComputationModeType (*this, f, c);
  }

  ComputationModeType::
  ~ComputationModeType ()
  {
  }

  // TwoDoublesType
  //

  TwoDoublesType::
  TwoDoublesType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::simple_type (e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ > (e, f, this)
  {
  }

  TwoDoublesType::
  TwoDoublesType (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::simple_type (a, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ > (a, f, this)
  {
  }

  TwoDoublesType::
  TwoDoublesType (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::simple_type (s, e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ > (s, e, f, this)
  {
  }

  TwoDoublesType* TwoDoublesType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class TwoDoublesType (*this, f, c);
  }

  TwoDoublesType::
  ~TwoDoublesType ()
  {
  }

  // RangeType
  //

  RangeType::
  RangeType (const range_type& range)
  : ::xml_schema::type (),
    range_ (range, ::xml_schema::flags (), this)
  {
  }

  RangeType::
  RangeType (const RangeType& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    range_ (x.range_, f, this)
  {
  }

  RangeType::
  RangeType (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    range_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void RangeType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // range
      //
      if (n.name () == "range" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< range_type > r (
          range_traits::create (i, f, this));

        if (!range_.present ())
        {
          this->range_.set (r);
          continue;
        }
      }

      break;
    }

    if (!range_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "range",
        "");
    }
  }

  RangeType* RangeType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class RangeType (*this, f, c);
  }

  RangeType::
  ~RangeType ()
  {
  }

  // MuscleListType
  //

  MuscleListType::
  MuscleListType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::simple_type (e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::string, char > (e, f, this)
  {
  }

  MuscleListType::
  MuscleListType (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::simple_type (a, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::string, char > (a, f, this)
  {
  }

  MuscleListType::
  MuscleListType (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::simple_type (s, e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::string, char > (s, e, f, this)
  {
  }

  MuscleListType* MuscleListType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class MuscleListType (*this, f, c);
  }

  MuscleListType::
  ~MuscleListType ()
  {
  }

  // MuscleGroupsType
  //

  MuscleGroupsType::
  MuscleGroupsType ()
  : ::xml_schema::type (),
    muscles_ (::xml_schema::flags (), this)
  {
  }

  MuscleGroupsType::
  MuscleGroupsType (const MuscleGroupsType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    muscles_ (x.muscles_, f, this)
  {
  }

  MuscleGroupsType::
  MuscleGroupsType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    muscles_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void MuscleGroupsType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // muscles
      //
      if (n.name () == "muscles" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< muscles_type > r (
          muscles_traits::create (i, f, this));

        this->muscles_.push_back (r);
        continue;
      }

      break;
    }
  }

  MuscleGroupsType* MuscleGroupsType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class MuscleGroupsType (*this, f, c);
  }

  MuscleGroupsType::
  ~MuscleGroupsType ()
  {
  }

  // ParameterType
  //

  ParameterType::
  ParameterType (const name_type& name)
  : ::xml_schema::type (),
    name_ (name, ::xml_schema::flags (), this),
    muscleGroups_ (::xml_schema::flags (), this),
    global_ (::xml_schema::flags (), this),
    single_ (::xml_schema::flags (), this),
    absolute_ (::xml_schema::flags (), this),
    relativeToSubjectValue_ (::xml_schema::flags (), this)
  {
  }

  ParameterType::
  ParameterType (const ParameterType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    name_ (x.name_, f, this),
    muscleGroups_ (x.muscleGroups_, f, this),
    global_ (x.global_, f, this),
    single_ (x.single_, f, this),
    absolute_ (x.absolute_, f, this),
    relativeToSubjectValue_ (x.relativeToSubjectValue_, f, this)
  {
  }

  ParameterType::
  ParameterType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    name_ (f, this),
    muscleGroups_ (f, this),
    global_ (f, this),
    single_ (f, this),
    absolute_ (f, this),
    relativeToSubjectValue_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void ParameterType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // name
      //
      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< name_type > r (
          name_traits::create (i, f, this));

        if (!name_.present ())
        {
          this->name_.set (r);
          continue;
        }
      }

      // muscleGroups
      //
      if (n.name () == "muscleGroups" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< muscleGroups_type > r (
          muscleGroups_traits::create (i, f, this));

        if (!this->muscleGroups_)
        {
          this->muscleGroups_.set (r);
          continue;
        }
      }

      // global
      //
      if (n.name () == "global" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< global_type > r (
          global_traits::create (i, f, this));

        if (!this->global_)
        {
          this->global_.set (r);
          continue;
        }
      }

      // single
      //
      if (n.name () == "single" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< single_type > r (
          single_traits::create (i, f, this));

        if (!this->single_)
        {
          this->single_.set (r);
          continue;
        }
      }

      // absolute
      //
      if (n.name () == "absolute" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< absolute_type > r (
          absolute_traits::create (i, f, this));

        if (!this->absolute_)
        {
          this->absolute_.set (r);
          continue;
        }
      }

      // relativeToSubjectValue
      //
      if (n.name () == "relativeToSubjectValue" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< relativeToSubjectValue_type > r (
          relativeToSubjectValue_traits::create (i, f, this));

        if (!this->relativeToSubjectValue_)
        {
          this->relativeToSubjectValue_.set (r);
          continue;
        }
      }

      break;
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "name",
        "");
    }
  }

  ParameterType* ParameterType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ParameterType (*this, f, c);
  }

  ParameterType::
  ~ParameterType ()
  {
  }

  // parameterSetType
  //

  parameterSetType::
  parameterSetType ()
  : ::xml_schema::type (),
    parameter_ (::xml_schema::flags (), this)
  {
  }

  parameterSetType::
  parameterSetType (const parameterSetType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    parameter_ (x.parameter_, f, this)
  {
  }

  parameterSetType::
  parameterSetType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    parameter_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void parameterSetType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // parameter
      //
      if (n.name () == "parameter" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< parameter_type > r (
          parameter_traits::create (i, f, this));

        this->parameter_.push_back (r);
        continue;
      }

      break;
    }
  }

  parameterSetType* parameterSetType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class parameterSetType (*this, f, c);
  }

  parameterSetType::
  ~parameterSetType ()
  {
  }

  // StepType
  //

  StepType::
  StepType (const dofs_type& dofs,
            const objectiveFunction_type& objectiveFunction,
            const computationMode_type& computationMode)
  : ::xml_schema::type (),
    dofs_ (dofs, ::xml_schema::flags (), this),
    objectiveFunction_ (objectiveFunction, ::xml_schema::flags (), this),
    computationMode_ (computationMode, ::xml_schema::flags (), this),
    strengthCoefficients_ShapeFactor_C1_C2_TendonSLackLength_single_ (::xml_schema::flags (), this),
    parameterSet_ (::xml_schema::flags (), this)
  {
  }

  StepType::
  StepType (const dofs_type& dofs,
            ::std::auto_ptr< objectiveFunction_type >& objectiveFunction,
            ::std::auto_ptr< computationMode_type >& computationMode)
  : ::xml_schema::type (),
    dofs_ (dofs, ::xml_schema::flags (), this),
    objectiveFunction_ (objectiveFunction, ::xml_schema::flags (), this),
    computationMode_ (computationMode, ::xml_schema::flags (), this),
    strengthCoefficients_ShapeFactor_C1_C2_TendonSLackLength_single_ (::xml_schema::flags (), this),
    parameterSet_ (::xml_schema::flags (), this)
  {
  }

  StepType::
  StepType (const StepType& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    dofs_ (x.dofs_, f, this),
    objectiveFunction_ (x.objectiveFunction_, f, this),
    computationMode_ (x.computationMode_, f, this),
    strengthCoefficients_ShapeFactor_C1_C2_TendonSLackLength_single_ (x.strengthCoefficients_ShapeFactor_C1_C2_TendonSLackLength_single_, f, this),
    parameterSet_ (x.parameterSet_, f, this)
  {
  }

  StepType::
  StepType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    dofs_ (f, this),
    objectiveFunction_ (f, this),
    computationMode_ (f, this),
    strengthCoefficients_ShapeFactor_C1_C2_TendonSLackLength_single_ (f, this),
    parameterSet_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void StepType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // dofs
      //
      if (n.name () == "dofs" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< dofs_type > r (
          dofs_traits::create (i, f, this));

        if (!dofs_.present ())
        {
          this->dofs_.set (r);
          continue;
        }
      }

      // objectiveFunction
      //
      if (n.name () == "objectiveFunction" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< objectiveFunction_type > r (
          objectiveFunction_traits::create (i, f, this));

        if (!objectiveFunction_.present ())
        {
          this->objectiveFunction_.set (r);
          continue;
        }
      }

      // computationMode
      //
      if (n.name () == "computationMode" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< computationMode_type > r (
          computationMode_traits::create (i, f, this));

        if (!computationMode_.present ())
        {
          this->computationMode_.set (r);
          continue;
        }
      }

      // strengthCoefficients_ShapeFactor_C1_C2_TendonSLackLength_single
      //
      if (n.name () == "strengthCoefficients_ShapeFactor_C1_C2_TendonSLackLength_single" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< strengthCoefficients_ShapeFactor_C1_C2_TendonSLackLength_single_type > r (
          strengthCoefficients_ShapeFactor_C1_C2_TendonSLackLength_single_traits::create (i, f, this));

        if (!this->strengthCoefficients_ShapeFactor_C1_C2_TendonSLackLength_single_)
        {
          this->strengthCoefficients_ShapeFactor_C1_C2_TendonSLackLength_single_.set (r);
          continue;
        }
      }

      // parameterSet
      //
      if (n.name () == "parameterSet" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< parameterSet_type > r (
          parameterSet_traits::create (i, f, this));

        if (!this->parameterSet_)
        {
          this->parameterSet_.set (r);
          continue;
        }
      }

      break;
    }

    if (!dofs_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "dofs",
        "");
    }

    if (!objectiveFunction_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "objectiveFunction",
        "");
    }

    if (!computationMode_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "computationMode",
        "");
    }
  }

  StepType* StepType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class StepType (*this, f, c);
  }

  StepType::
  ~StepType ()
  {
  }

  // CalibrationStepsType
  //

  CalibrationStepsType::
  CalibrationStepsType ()
  : ::xml_schema::type (),
    step_ (::xml_schema::flags (), this)
  {
  }

  CalibrationStepsType::
  CalibrationStepsType (const CalibrationStepsType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    step_ (x.step_, f, this)
  {
  }

  CalibrationStepsType::
  CalibrationStepsType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    step_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void CalibrationStepsType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // step
      //
      if (n.name () == "step" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< step_type > r (
          step_traits::create (i, f, this));

        this->step_.push_back (r);
        continue;
      }

      break;
    }
  }

  CalibrationStepsType* CalibrationStepsType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CalibrationStepsType (*this, f, c);
  }

  CalibrationStepsType::
  ~CalibrationStepsType ()
  {
  }

  // CalibrationType
  //

  CalibrationType::
  CalibrationType (const algorithm_type& algorithm,
                   const NMSmodel_type& NMSmodel,
                   const calibrationSteps_type& calibrationSteps,
                   const trialsDirectory_type& trialsDirectory,
                   const trialSet_type& trialSet)
  : ::xml_schema::type (),
    algorithm_ (algorithm, ::xml_schema::flags (), this),
    NMSmodel_ (NMSmodel, ::xml_schema::flags (), this),
    samplingFrequency_ (::xml_schema::flags (), this),
    calibrationSteps_ (calibrationSteps, ::xml_schema::flags (), this),
    trialsDirectory_ (trialsDirectory, ::xml_schema::flags (), this),
    trialSet_ (trialSet, ::xml_schema::flags (), this)
  {
  }

  CalibrationType::
  CalibrationType (::std::auto_ptr< algorithm_type >& algorithm,
                   ::std::auto_ptr< NMSmodel_type >& NMSmodel,
                   ::std::auto_ptr< calibrationSteps_type >& calibrationSteps,
                   const trialsDirectory_type& trialsDirectory,
                   const trialSet_type& trialSet)
  : ::xml_schema::type (),
    algorithm_ (algorithm, ::xml_schema::flags (), this),
    NMSmodel_ (NMSmodel, ::xml_schema::flags (), this),
    samplingFrequency_ (::xml_schema::flags (), this),
    calibrationSteps_ (calibrationSteps, ::xml_schema::flags (), this),
    trialsDirectory_ (trialsDirectory, ::xml_schema::flags (), this),
    trialSet_ (trialSet, ::xml_schema::flags (), this)
  {
  }

  CalibrationType::
  CalibrationType (const CalibrationType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    algorithm_ (x.algorithm_, f, this),
    NMSmodel_ (x.NMSmodel_, f, this),
    samplingFrequency_ (x.samplingFrequency_, f, this),
    calibrationSteps_ (x.calibrationSteps_, f, this),
    trialsDirectory_ (x.trialsDirectory_, f, this),
    trialSet_ (x.trialSet_, f, this)
  {
  }

  CalibrationType::
  CalibrationType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    algorithm_ (f, this),
    NMSmodel_ (f, this),
    samplingFrequency_ (f, this),
    calibrationSteps_ (f, this),
    trialsDirectory_ (f, this),
    trialSet_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void CalibrationType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // algorithm
      //
      if (n.name () == "algorithm" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< algorithm_type > r (
          algorithm_traits::create (i, f, this));

        if (!algorithm_.present ())
        {
          this->algorithm_.set (r);
          continue;
        }
      }

      // NMSmodel
      //
      if (n.name () == "NMSmodel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< NMSmodel_type > r (
          NMSmodel_traits::create (i, f, this));

        if (!NMSmodel_.present ())
        {
          this->NMSmodel_.set (r);
          continue;
        }
      }

      // samplingFrequency
      //
      if (n.name () == "samplingFrequency" && n.namespace_ ().empty ())
      {
        if (!this->samplingFrequency_)
        {
          this->samplingFrequency_.set (samplingFrequency_traits::create (i, f, this));
          continue;
        }
      }

      // calibrationSteps
      //
      if (n.name () == "calibrationSteps" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< calibrationSteps_type > r (
          calibrationSteps_traits::create (i, f, this));

        if (!calibrationSteps_.present ())
        {
          this->calibrationSteps_.set (r);
          continue;
        }
      }

      // trialsDirectory
      //
      if (n.name () == "trialsDirectory" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< trialsDirectory_type > r (
          trialsDirectory_traits::create (i, f, this));

        if (!trialsDirectory_.present ())
        {
          this->trialsDirectory_.set (r);
          continue;
        }
      }

      // trialSet
      //
      if (n.name () == "trialSet" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< trialSet_type > r (
          trialSet_traits::create (i, f, this));

        if (!trialSet_.present ())
        {
          this->trialSet_.set (r);
          continue;
        }
      }

      break;
    }

    if (!algorithm_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "algorithm",
        "");
    }

    if (!NMSmodel_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "NMSmodel",
        "");
    }

    if (!calibrationSteps_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "calibrationSteps",
        "");
    }

    if (!trialsDirectory_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "trialsDirectory",
        "");
    }

    if (!trialSet_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "trialSet",
        "");
    }
  }

  CalibrationType* CalibrationType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CalibrationType (*this, f, c);
  }

  CalibrationType::
  ~CalibrationType ()
  {
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace CalibrationXsd
{
  ::std::auto_ptr< ::CalibrationXsd::CalibrationType >
  calibration (const ::std::string& u,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::CalibrationXsd::CalibrationType > r (
      ::CalibrationXsd::calibration (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::CalibrationXsd::CalibrationType >
  calibration (const ::std::string& u,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::CalibrationXsd::CalibrationType > r (
      ::CalibrationXsd::calibration (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::CalibrationXsd::CalibrationType >
  calibration (const ::std::string& u,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::CalibrationXsd::CalibrationType > r (
      ::CalibrationXsd::calibration (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::CalibrationXsd::CalibrationType >
  calibration (::std::istream& is,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::CalibrationXsd::calibration (isrc, f, p);
  }

  ::std::auto_ptr< ::CalibrationXsd::CalibrationType >
  calibration (::std::istream& is,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::CalibrationXsd::calibration (isrc, h, f, p);
  }

  ::std::auto_ptr< ::CalibrationXsd::CalibrationType >
  calibration (::std::istream& is,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::CalibrationXsd::calibration (isrc, h, f, p);
  }

  ::std::auto_ptr< ::CalibrationXsd::CalibrationType >
  calibration (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::CalibrationXsd::calibration (isrc, f, p);
  }

  ::std::auto_ptr< ::CalibrationXsd::CalibrationType >
  calibration (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::CalibrationXsd::calibration (isrc, h, f, p);
  }

  ::std::auto_ptr< ::CalibrationXsd::CalibrationType >
  calibration (::std::istream& is,
               const ::std::string& sid,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::CalibrationXsd::calibration (isrc, h, f, p);
  }

  ::std::auto_ptr< ::CalibrationXsd::CalibrationType >
  calibration (::xercesc::InputSource& i,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::CalibrationXsd::CalibrationType > r (
      ::CalibrationXsd::calibration (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::CalibrationXsd::CalibrationType >
  calibration (::xercesc::InputSource& i,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::CalibrationXsd::CalibrationType > r (
      ::CalibrationXsd::calibration (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::CalibrationXsd::CalibrationType >
  calibration (::xercesc::InputSource& i,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::CalibrationXsd::CalibrationType > r (
      ::CalibrationXsd::calibration (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::CalibrationXsd::CalibrationType >
  calibration (const ::xercesc::DOMDocument& d,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::CalibrationXsd::CalibrationType > r (
        ::CalibrationXsd::calibration (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "calibration" &&
        n.namespace_ () == "")
    {
      ::std::auto_ptr< ::CalibrationXsd::CalibrationType > r (
        ::xsd::cxx::tree::traits< ::CalibrationXsd::CalibrationType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "calibration",
      "");
  }

  ::std::auto_ptr< ::CalibrationXsd::CalibrationType >
  calibration (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
               ::xml_schema::flags f,
               const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "calibration" &&
        n.namespace_ () == "")
    {
      ::std::auto_ptr< ::CalibrationXsd::CalibrationType > r (
        ::xsd::cxx::tree::traits< ::CalibrationXsd::CalibrationType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "calibration",
      "");
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

namespace CalibrationXsd
{
  void
  operator<< (::xercesc::DOMElement& e, const SimulatedAnnealingType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // noEpsilon
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "noEpsilon",
          e));

      s << i.noEpsilon ();
    }

    // rt
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "rt",
          e));

      s << ::xml_schema::as_double(i.rt ());
    }

    // T
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "T",
          e));

      s << ::xml_schema::as_double(i.T ());
    }

    // NS
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "NS",
          e));

      s << i.NS ();
    }

    // NT
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "NT",
          e));

      s << i.NT ();
    }

    // epsilon
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "epsilon",
          e));

      s << ::xml_schema::as_double(i.epsilon ());
    }

    // maxNoEval
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "maxNoEval",
          e));

      s << i.maxNoEval ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const AlgorithmType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // simulatedAnnealing
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "simulatedAnnealing",
          e));

      s << i.simulatedAnnealing ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const OpenLoopType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr&, const OpenLoopType&)
  {
  }

  void
  operator<< (::xml_schema::list_stream&,
              const OpenLoopType&)
  {
  }

  void
  operator<< (::xercesc::DOMElement& e, const TypeType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // openLoop
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "openLoop",
          e));

      s << i.openLoop ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const TendonElementType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr&, const TendonElementType&)
  {
  }

  void
  operator<< (::xml_schema::list_stream&,
              const TendonElementType&)
  {
  }

  void
  operator<< (::xercesc::DOMElement& e, const TendonType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // stiff
    //
    if (i.stiff ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "stiff",
          e));

      s << *i.stiff ();
    }

    // elastic
    //
    if (i.elastic ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "elastic",
          e));

      s << *i.elastic ();
    }

    // elasticBiSec
    //
    if (i.elasticBiSec ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "elasticBiSec",
          e));

      s << *i.elasticBiSec ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ActivationElementType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr&, const ActivationElementType&)
  {
  }

  void
  operator<< (::xml_schema::list_stream&,
              const ActivationElementType&)
  {
  }

  void
  operator<< (::xercesc::DOMElement& e, const ActivationType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // exponential
    //
    if (i.exponential ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "exponential",
          e));

      s << *i.exponential ();
    }

    // piecewise
    //
    if (i.piecewise ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "piecewise",
          e));

      s << *i.piecewise ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const NMSModelType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // type
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "type",
          e));

      s << i.type ();
    }

    // tendon
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "tendon",
          e));

      s << i.tendon ();
    }

    // activation
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "activation",
          e));

      s << i.activation ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const TrialSetType& i)
  {
    e << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::string, char >& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const TrialSetType& i)
  {
    a << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::string, char >& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const TrialSetType& i)
  {
    l << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::string, char >& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const ObjectiveFunctionElementType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr&, const ObjectiveFunctionElementType&)
  {
  }

  void
  operator<< (::xml_schema::list_stream&,
              const ObjectiveFunctionElementType&)
  {
  }

  void
  operator<< (::xercesc::DOMElement& e, const ComputationModeElementType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr&, const ComputationModeElementType&)
  {
  }

  void
  operator<< (::xml_schema::list_stream&,
              const ComputationModeElementType&)
  {
  }

  void
  operator<< (::xercesc::DOMElement& e, const GlobalParameterType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr&, const GlobalParameterType&)
  {
  }

  void
  operator<< (::xml_schema::list_stream&,
              const GlobalParameterType&)
  {
  }

  void
  operator<< (::xercesc::DOMElement& e, const SingleParameterType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr&, const SingleParameterType&)
  {
  }

  void
  operator<< (::xml_schema::list_stream&,
              const SingleParameterType&)
  {
  }

  void
  operator<< (::xercesc::DOMElement& e, const ObjectiveFunctionType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // minimizeTorqueError
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "minimizeTorqueError",
          e));

      s << i.minimizeTorqueError ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const DoFsType& i)
  {
    e << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::string, char >& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const DoFsType& i)
  {
    a << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::string, char >& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const DoFsType& i)
  {
    l << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::string, char >& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const HardCodedParametersSelectionType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr&, const HardCodedParametersSelectionType&)
  {
  }

  void
  operator<< (::xml_schema::list_stream&,
              const HardCodedParametersSelectionType&)
  {
  }

  void
  operator<< (::xercesc::DOMElement& e, const ComputationModeType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // default
    //
    if (i.default_ ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "default",
          e));

      s << *i.default_ ();
    }

    // fast
    //
    if (i.fast ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "fast",
          e));

      s << *i.fast ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const TwoDoublesType& i)
  {
    e << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ >& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const TwoDoublesType& i)
  {
    a << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ >& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const TwoDoublesType& i)
  {
    l << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ >& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const RangeType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // range
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "range",
          e));

      s << i.range ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const MuscleListType& i)
  {
    e << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::string, char >& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const MuscleListType& i)
  {
    a << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::string, char >& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const MuscleListType& i)
  {
    l << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::string, char >& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const MuscleGroupsType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // muscles
    //
    for (MuscleGroupsType::muscles_const_iterator
         b (i.muscles ().begin ()), n (i.muscles ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "muscles",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ParameterType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // name
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "name",
          e));

      s << i.name ();
    }

    // muscleGroups
    //
    if (i.muscleGroups ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "muscleGroups",
          e));

      s << *i.muscleGroups ();
    }

    // global
    //
    if (i.global ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "global",
          e));

      s << *i.global ();
    }

    // single
    //
    if (i.single ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "single",
          e));

      s << *i.single ();
    }

    // absolute
    //
    if (i.absolute ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "absolute",
          e));

      s << *i.absolute ();
    }

    // relativeToSubjectValue
    //
    if (i.relativeToSubjectValue ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "relativeToSubjectValue",
          e));

      s << *i.relativeToSubjectValue ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const parameterSetType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // parameter
    //
    for (parameterSetType::parameter_const_iterator
         b (i.parameter ().begin ()), n (i.parameter ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "parameter",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const StepType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // dofs
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "dofs",
          e));

      s << i.dofs ();
    }

    // objectiveFunction
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "objectiveFunction",
          e));

      s << i.objectiveFunction ();
    }

    // computationMode
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "computationMode",
          e));

      s << i.computationMode ();
    }

    // strengthCoefficients_ShapeFactor_C1_C2_TendonSLackLength_single
    //
    if (i.strengthCoefficients_ShapeFactor_C1_C2_TendonSLackLength_single ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "strengthCoefficients_ShapeFactor_C1_C2_TendonSLackLength_single",
          e));

      s << *i.strengthCoefficients_ShapeFactor_C1_C2_TendonSLackLength_single ();
    }

    // parameterSet
    //
    if (i.parameterSet ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "parameterSet",
          e));

      s << *i.parameterSet ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const CalibrationStepsType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // step
    //
    for (CalibrationStepsType::step_const_iterator
         b (i.step ().begin ()), n (i.step ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "step",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const CalibrationType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // algorithm
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "algorithm",
          e));

      s << i.algorithm ();
    }

    // NMSmodel
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "NMSmodel",
          e));

      s << i.NMSmodel ();
    }

    // samplingFrequency
    //
    if (i.samplingFrequency ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "samplingFrequency",
          e));

      s << *i.samplingFrequency ();
    }

    // calibrationSteps
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "calibrationSteps",
          e));

      s << i.calibrationSteps ();
    }

    // trialsDirectory
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "trialsDirectory",
          e));

      s << i.trialsDirectory ();
    }

    // trialSet
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "trialSet",
          e));

      s << i.trialSet ();
    }
  }

  void
  calibration (::std::ostream& o,
               const ::CalibrationXsd::CalibrationType& s,
               const ::xml_schema::namespace_infomap& m,
               const ::std::string& e,
               ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::CalibrationXsd::calibration (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  calibration (::std::ostream& o,
               const ::CalibrationXsd::CalibrationType& s,
               ::xml_schema::error_handler& h,
               const ::xml_schema::namespace_infomap& m,
               const ::std::string& e,
               ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::CalibrationXsd::calibration (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  calibration (::std::ostream& o,
               const ::CalibrationXsd::CalibrationType& s,
               ::xercesc::DOMErrorHandler& h,
               const ::xml_schema::namespace_infomap& m,
               const ::std::string& e,
               ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::CalibrationXsd::calibration (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  calibration (::xercesc::XMLFormatTarget& t,
               const ::CalibrationXsd::CalibrationType& s,
               const ::xml_schema::namespace_infomap& m,
               const ::std::string& e,
               ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::CalibrationXsd::calibration (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  calibration (::xercesc::XMLFormatTarget& t,
               const ::CalibrationXsd::CalibrationType& s,
               ::xml_schema::error_handler& h,
               const ::xml_schema::namespace_infomap& m,
               const ::std::string& e,
               ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::CalibrationXsd::calibration (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  calibration (::xercesc::XMLFormatTarget& t,
               const ::CalibrationXsd::CalibrationType& s,
               ::xercesc::DOMErrorHandler& h,
               const ::xml_schema::namespace_infomap& m,
               const ::std::string& e,
               ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::CalibrationXsd::calibration (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  calibration (::xercesc::DOMDocument& d,
               const ::CalibrationXsd::CalibrationType& s,
               ::xml_schema::flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "calibration" &&
        n.namespace_ () == "")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "calibration",
        "");
    }
  }

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
  calibration (const ::CalibrationXsd::CalibrationType& s,
               const ::xml_schema::namespace_infomap& m,
               ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "calibration",
        "",
        m, f));

    ::CalibrationXsd::calibration (*d, s, f);
    return d;
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

